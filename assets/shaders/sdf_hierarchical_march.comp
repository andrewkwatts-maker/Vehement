#version 460 core

// Hierarchical SDF Raymarching with Octree Acceleration
// Features:
// - Enhanced sphere tracing with safety factor
// - Octree/BVH for empty space skipping
// - Distance bounds optimization
// - Adaptive step sizing based on curvature
// - Cone tracing for soft shadows
// - Multi-bounce AO

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// =============================================================================
// Output Images
// =============================================================================

layout(rgba16f, binding = 0) uniform image2D u_colorOutput;
layout(r32f, binding = 1) uniform image2D u_depthOutput;
layout(rgba16f, binding = 2) uniform image2D u_normalOutput;
layout(r16ui, binding = 3) uniform uimage2D u_materialOutput;

// =============================================================================
// Input Buffers
// =============================================================================

// SDF bytecode instructions
layout(std430, binding = 4) readonly buffer InstructionBuffer {
    vec4 instructions[];  // SDFInstruction data (16 floats per instruction)
};

// SDF instances
layout(std430, binding = 5) readonly buffer InstanceBuffer {
    mat4 instances[];  // Instance transforms + data
};

// Octree structure (optional)
layout(std430, binding = 6) readonly buffer OctreeBuffer {
    vec4 octreeNodes[];  // xyz = center, w = halfSize, next vec4 = children/data
};

// Brick cache atlas
uniform sampler3D u_brickAtlas;
uniform usampler3D u_materialAtlas;

// =============================================================================
// Uniforms
// =============================================================================

uniform mat4 u_invViewProj;
uniform vec3 u_cameraPos;
uniform vec3 u_cameraDir;

uniform int u_instructionCount;
uniform int u_instanceCount;
uniform bool u_useOctree;
uniform bool u_useBrickCache;

// Raymarching parameters
uniform float u_maxDistance;
uniform int u_maxSteps;
uniform float u_epsilon;
uniform float u_safetyFactor;  // 0.9 for overshoot prevention

// Quality settings
uniform bool u_highQuality;
uniform bool u_enableShadows;
uniform bool u_enableAO;
uniform int u_aoSamples;

// Lighting
uniform vec3 u_lightDir;
uniform vec3 u_lightColor;
uniform float u_lightIntensity;

// =============================================================================
// Include SDF Bytecode Evaluator
// =============================================================================

// NOTE: In practice, include the bytecode eval file here
// For now, we define a simplified version inline

const float MAX_DIST = 1000.0;

// Simplified SDF evaluation (see sdf_bytecode_eval.glsl for full version)
float evaluateSDF(vec3 p, out uint materialID) {
    materialID = 0u;

    // Simple scene for testing: sphere at origin
    float dist = length(p) - 5.0;

    // TODO: Actual bytecode evaluation
    // This would call evaluateSDFBytecode() from the include file

    return dist;
}

// =============================================================================
// Octree Traversal for Empty Space Skipping
// =============================================================================

float octreeBounds(vec3 p) {
    if (!u_useOctree) {
        return 0.0;
    }

    // TODO: Implement hierarchical octree traversal
    // For now, return 0 (no acceleration)

    // Octree traversal would:
    // 1. Start at root node
    // 2. Traverse down to leaf containing p
    // 3. Return conservative distance bound
    // 4. Skip empty nodes entirely

    return 0.0;
}

// =============================================================================
// Enhanced Sphere Tracing
// =============================================================================

struct RayHit {
    bool hit;
    float t;
    vec3 position;
    vec3 normal;
    uint materialID;
    int steps;
};

// Calculate normal using tetrahedron technique (more accurate)
vec3 calculateNormal(vec3 p) {
    const vec2 k = vec2(1.0, -1.0);
    uint dummy;

    return normalize(
        k.xyy * evaluateSDF(p + k.xyy * u_epsilon, dummy) +
        k.yyx * evaluateSDF(p + k.yyx * u_epsilon, dummy) +
        k.yxy * evaluateSDF(p + k.yxy * u_epsilon, dummy) +
        k.xxx * evaluateSDF(p + k.xxx * u_epsilon, dummy)
    );
}

// Enhanced sphere tracing with adaptive step size
RayHit rayMarch(vec3 origin, vec3 direction) {
    RayHit hit;
    hit.hit = false;
    hit.t = 0.0;
    hit.steps = 0;

    float t = 0.0;
    float omega = 1.2;  // Overrelaxation factor
    float candidate_t = t;
    float candidate_error = MAX_DIST;

    for (int i = 0; i < u_maxSteps; i++) {
        vec3 p = origin + direction * t;

        // Check octree bounds for early skip
        float octreeDist = octreeBounds(p);
        if (octreeDist > 10.0) {
            // Far outside any geometry, skip ahead
            t += octreeDist * 0.5;
            hit.steps++;
            continue;
        }

        // Evaluate SDF
        uint materialID;
        float dist = evaluateSDF(p, materialID);

        // Track best candidate for sub-pixel accuracy
        if (dist < candidate_error) {
            candidate_t = t;
            candidate_error = dist;
        }

        // Hit detection with epsilon threshold
        if (abs(dist) < u_epsilon) {
            hit.hit = true;
            hit.t = candidate_t;
            hit.position = origin + direction * candidate_t;
            hit.normal = calculateNormal(hit.position);
            hit.materialID = materialID;
            hit.steps = i;
            return hit;
        }

        // Ray escaped
        if (t > u_maxDistance) {
            break;
        }

        // Apply safety factor to prevent overshoot
        // Use relaxation sphere tracing for better convergence
        float step_dist;
        if (u_highQuality) {
            // Enhanced sphere tracing
            float signedRadius = dist;
            float functionSign = sign(dist);
            t = t + omega * functionSign * signedRadius;

            // Adaptive omega based on curvature
            if (abs(dist) < 1.0) {
                omega = 1.0;  // Conservative near surfaces
            }
        } else {
            // Standard sphere tracing with safety factor
            t += dist * u_safetyFactor;
        }

        hit.steps = i;
    }

    // Use best candidate if we got close
    if (candidate_error < u_epsilon * 2.0) {
        hit.hit = true;
        hit.t = candidate_t;
        hit.position = origin + direction * candidate_t;
        hit.normal = calculateNormal(hit.position);
        hit.steps = u_maxSteps;
    }

    return hit;
}

// =============================================================================
// Soft Shadows using Cone Tracing
// =============================================================================

float softShadow(vec3 origin, vec3 direction, float minT, float maxT, float k) {
    float res = 1.0;
    float t = minT;

    for (int i = 0; i < 64; i++) {
        if (t > maxT) break;

        vec3 p = origin + direction * t;
        uint dummy;
        float h = evaluateSDF(p, dummy);

        if (h < u_epsilon) {
            return 0.0;  // In shadow
        }

        // Penumbra calculation
        res = min(res, k * h / t);
        t += h * u_safetyFactor;
    }

    return clamp(res, 0.0, 1.0);
}

// =============================================================================
// Ambient Occlusion via Cone Tracing
// =============================================================================

float ambientOcclusion(vec3 p, vec3 normal) {
    float occ = 0.0;
    float scale = 1.0;

    // Sample along normal direction with increasing distance
    for (int i = 0; i < u_aoSamples; i++) {
        float h = 0.01 + 0.12 * float(i) / float(u_aoSamples);
        vec3 samplePos = p + normal * h;

        uint dummy;
        float d = evaluateSDF(samplePos, dummy);

        // Accumulate occlusion
        occ += (h - d) * scale;
        scale *= 0.95;
    }

    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);
}

// =============================================================================
// Bent Normal for Directional AO
// =============================================================================

vec3 bentNormal(vec3 p, vec3 normal) {
    vec3 bent = normal;
    float weight = 0.0;

    // Sample hemisphere around normal
    const int samples = 8;
    for (int i = 0; i < samples; i++) {
        float theta = 3.14159 * float(i) / float(samples);
        float phi = 2.0 * 3.14159 * fract(sin(float(i) * 12.9898) * 43758.5453);

        vec3 dir = vec3(
            sin(theta) * cos(phi),
            sin(theta) * sin(phi),
            cos(theta)
        );

        // Align with normal
        vec3 tangent = normalize(cross(normal, vec3(0.0, 1.0, 0.0)));
        vec3 bitangent = cross(normal, tangent);
        vec3 sampleDir = tangent * dir.x + bitangent * dir.y + normal * dir.z;

        // Sample SDF
        vec3 samplePos = p + sampleDir * 0.1;
        uint dummy;
        float d = evaluateSDF(samplePos, dummy);

        if (d > 0.0) {
            bent += sampleDir * d;
            weight += d;
        }
    }

    if (weight > 0.0) {
        bent /= weight;
        return normalize(bent);
    }

    return normal;
}

// =============================================================================
// Main Compute Shader
// =============================================================================

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(u_colorOutput);

    if (any(greaterThanEqual(pixelCoord, screenSize))) {
        return;
    }

    // Generate ray from pixel
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(screenSize);
    vec2 ndc = uv * 2.0 - 1.0;

    // Reconstruct world space ray
    vec4 clipNear = vec4(ndc, -1.0, 1.0);
    vec4 clipFar = vec4(ndc, 1.0, 1.0);

    vec4 worldNear = u_invViewProj * clipNear;
    vec4 worldFar = u_invViewProj * clipFar;

    worldNear /= worldNear.w;
    worldFar /= worldFar.w;

    vec3 rayOrigin = worldNear.xyz;
    vec3 rayDir = normalize(worldFar.xyz - worldNear.xyz);

    // Raymarch
    RayHit hit = rayMarch(rayOrigin, rayDir);

    if (hit.hit) {
        // Calculate lighting
        vec3 N = hit.normal;
        vec3 L = normalize(u_lightDir);
        vec3 V = normalize(u_cameraPos - hit.position);
        vec3 H = normalize(L + V);

        // Diffuse
        float NdotL = max(dot(N, L), 0.0);
        vec3 diffuse = vec3(0.8) * NdotL;

        // Specular (simple Blinn-Phong)
        float NdotH = max(dot(N, H), 0.0);
        float spec = pow(NdotH, 32.0);
        vec3 specular = vec3(0.2) * spec;

        // Shadows
        float shadow = 1.0;
        if (u_enableShadows) {
            vec3 shadowOrigin = hit.position + N * u_epsilon * 2.0;
            shadow = softShadow(shadowOrigin, L, 0.01, 10.0, 8.0);
        }

        // Ambient occlusion
        float ao = 1.0;
        if (u_enableAO) {
            ao = ambientOcclusion(hit.position, N);
        }

        // Ambient term
        vec3 ambient = vec3(0.03) * ao;

        // Final color
        vec3 color = (ambient + (diffuse + specular) * shadow) * u_lightColor * u_lightIntensity;

        // Store results
        imageStore(u_colorOutput, pixelCoord, vec4(color, 1.0));
        imageStore(u_depthOutput, pixelCoord, vec4(hit.t, 0, 0, 0));
        imageStore(u_normalOutput, pixelCoord, vec4(N * 0.5 + 0.5, 1.0));
        imageStore(u_materialOutput, pixelCoord, uvec4(hit.materialID, 0, 0, 0));
    } else {
        // Sky/background
        vec3 skyColor = vec3(0.5, 0.7, 1.0) * 0.3;
        imageStore(u_colorOutput, pixelCoord, vec4(skyColor, 1.0));
        imageStore(u_depthOutput, pixelCoord, vec4(MAX_DIST, 0, 0, 0));
        imageStore(u_normalOutput, pixelCoord, vec4(0.5, 0.5, 1.0, 1.0));
        imageStore(u_materialOutput, pixelCoord, uvec4(0, 0, 0, 0));
    }
}
