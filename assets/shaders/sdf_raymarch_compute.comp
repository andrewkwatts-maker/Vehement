#version 460 core

// Compute shader for SDF raymarching
// Uses same primitive format as fragment shader for easy integration

layout(local_size_x = 16, local_size_y = 16) in;

// Output texture
layout(binding = 0, rgba16f) uniform writeonly image2D u_colorOutput;

// Camera uniforms
uniform mat4 u_view;
uniform mat4 u_projection;
uniform mat4 u_invView;
uniform mat4 u_invProjection;
uniform vec3 u_cameraPos;
uniform vec3 u_cameraDir;
uniform ivec2 u_resolution;

// Raymarching settings
uniform int u_maxSteps;
uniform float u_maxDistance;
uniform float u_hitThreshold;

// Quality settings
uniform int u_enableShadows;
uniform int u_enableAO;
uniform int u_enableReflections;

// Shadow settings
uniform float u_shadowSoftness;
uniform int u_shadowSteps;

// AO settings
uniform int u_aoSteps;
uniform float u_aoDistance;
uniform float u_aoIntensity;

// Lighting
uniform vec3 u_lightDirection;
uniform vec3 u_lightColor;
uniform float u_lightIntensity;

// Background
uniform vec3 u_backgroundColor;

// Primitive data
uniform int u_primitiveCount;

// Primitive types
const int PRIM_SPHERE = 0;
const int PRIM_BOX = 1;
const int PRIM_CYLINDER = 2;
const int PRIM_CAPSULE = 3;
const int PRIM_CONE = 4;
const int PRIM_TORUS = 5;
const int PRIM_PLANE = 6;
const int PRIM_ROUNDED_BOX = 7;
const int PRIM_ELLIPSOID = 8;
const int PRIM_PYRAMID = 9;
const int PRIM_PRISM = 10;

// CSG operations
const int CSG_UNION = 0;
const int CSG_SUBTRACTION = 1;
const int CSG_INTERSECTION = 2;
const int CSG_SMOOTH_UNION = 3;
const int CSG_SMOOTH_SUBTRACTION = 4;
const int CSG_SMOOTH_INTERSECTION = 5;

// Primitive data structure (matches SDFPrimitiveData in C++)
struct SDFPrimitive {
    mat4 transform;
    mat4 inverseTransform;
    vec4 parameters;      // radius, dimensions.xyz
    vec4 parameters2;     // height, topRadius, bottomRadius, cornerRadius
    vec4 parameters3;     // majorRadius, minorRadius, smoothness, sides
    vec4 material;        // metallic, roughness, emissive, unused
    vec4 baseColor;
    vec4 emissiveColor;
    vec4 boundingSphere;  // xyz = world center, w = bounding radius
    int type;
    int csgOperation;
    int visible;
    int parentIndex;
};

// SSBO for primitives
layout(std430, binding = 0) readonly buffer PrimitivesBuffer {
    SDFPrimitive primitives[];
};

// ===========================================================================
// SDF Primitive Functions
// ===========================================================================

float sdSphere(vec3 p, float r) {
    return length(p) - r;
}

float sdBox(vec3 p, vec3 b) {
    vec3 q = abs(p) - b;
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
}

float sdRoundedBox(vec3 p, vec3 b, float r) {
    vec3 q = abs(p) - b + vec3(r);
    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - r;
}

float sdCylinder(vec3 p, float h, float r) {
    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

float sdCapsule(vec3 p, float h, float r) {
    float halfHeight = h * 0.5 - r;
    p.y -= clamp(p.y, -halfHeight, halfHeight);
    return length(p) - r;
}

float sdCone(vec3 p, float h, float r) {
    vec2 c = normalize(vec2(r, h));
    float q = length(p.xz);
    return dot(c, vec2(q, p.y + h * 0.5));
}

float sdTorus(vec3 p, float R, float r) {
    vec2 q = vec2(length(p.xz) - R, p.y);
    return length(q) - r;
}

float sdPlane(vec3 p, vec3 n, float offset) {
    return dot(p, n) + offset;
}

float sdEllipsoid(vec3 p, vec3 r) {
    float k0 = length(p / r);
    float k1 = length(p / (r * r));
    return k0 * (k0 - 1.0) / k1;
}

float sdPyramid(vec3 p, float h, float baseSize) {
    p.y += h * 0.5;
    float m2 = h * h + 0.25;
    vec2 pxz = abs(p.xz);
    if (pxz.y > pxz.x) pxz = pxz.yx;
    pxz -= baseSize * 0.5;
    vec3 q = vec3(pxz.y, h * pxz.x - baseSize * 0.5 * p.y, h * p.y + baseSize * 0.5 * pxz.x);
    float s = max(-q.x, 0.0);
    float t = clamp((q.y - 0.5 * baseSize * q.z) / (m2 + 0.25 * baseSize * baseSize), 0.0, 1.0);
    float a = m2 * (q.x + s) * (q.x + s) + q.y * q.y;
    float b = m2 * (q.x + 0.5 * t) * (q.x + 0.5 * t) + (q.y - m2 * t) * (q.y - m2 * t);
    float d2 = max(-q.y, q.x * m2 + q.y * 0.5) < 0.0 ? 0.0 : min(a, b);
    return sqrt((d2 + q.z * q.z) / m2) * sign(max(q.z, -p.y));
}

float sdPrism(vec3 p, int n, float r, float h) {
    float an = 3.141592653 / float(n);
    vec2 acs = vec2(cos(an), sin(an));
    float bn = mod(atan(p.x, p.z), 2.0 * an) - an;
    vec2 d = abs(vec2(length(p.xz) * cos(bn), p.y)) - vec2(r * acs.y, h * 0.5);
    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));
}

// ===========================================================================
// CSG Operations
// ===========================================================================

float opUnion(float d1, float d2) {
    return min(d1, d2);
}

float opSubtraction(float d1, float d2) {
    return max(-d1, d2);
}

float opIntersection(float d1, float d2) {
    return max(d1, d2);
}

float opSmoothUnion(float d1, float d2, float k) {
    float h = clamp(0.5 + 0.5*(d2-d1)/k, 0.0, 1.0);
    return mix(d2, d1, h) - k*h*(1.0-h);
}

float opSmoothSubtraction(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5*(d2+d1)/k, 0.0, 1.0);
    return mix(d2, -d1, h) + k*h*(1.0-h);
}

float opSmoothIntersection(float d1, float d2, float k) {
    float h = clamp(0.5 - 0.5*(d2-d1)/k, 0.0, 1.0);
    return mix(d2, d1, h) + k*h*(1.0-h);
}

// ===========================================================================
// Primitive Evaluation
// ===========================================================================

float evaluatePrimitive(SDFPrimitive prim, vec3 p) {
    vec3 localPos = (prim.inverseTransform * vec4(p, 1.0)).xyz;
    float dist = 1e10;

    if (prim.type == PRIM_SPHERE) {
        dist = sdSphere(localPos, prim.parameters.x);
    }
    else if (prim.type == PRIM_BOX) {
        dist = sdBox(localPos, prim.parameters.yzw);
    }
    else if (prim.type == PRIM_CYLINDER) {
        dist = sdCylinder(localPos, prim.parameters2.x, prim.parameters.x);
    }
    else if (prim.type == PRIM_CAPSULE) {
        dist = sdCapsule(localPos, prim.parameters2.x, prim.parameters.x);
    }
    else if (prim.type == PRIM_CONE) {
        dist = sdCone(localPos, prim.parameters2.x, prim.parameters.x);
    }
    else if (prim.type == PRIM_TORUS) {
        dist = sdTorus(localPos, prim.parameters3.x, prim.parameters3.y);
    }
    else if (prim.type == PRIM_PLANE) {
        dist = sdPlane(localPos, vec3(0.0, 1.0, 0.0), 0.0);
    }
    else if (prim.type == PRIM_ROUNDED_BOX) {
        dist = sdRoundedBox(localPos, prim.parameters.yzw, prim.parameters2.w);
    }
    else if (prim.type == PRIM_ELLIPSOID) {
        dist = sdEllipsoid(localPos, prim.parameters.yzw);
    }
    else if (prim.type == PRIM_PYRAMID) {
        dist = sdPyramid(localPos, prim.parameters2.x, prim.parameters.y);
    }
    else if (prim.type == PRIM_PRISM) {
        int sides = int(prim.parameters3.w);
        dist = sdPrism(localPos, sides, prim.parameters2.z, prim.parameters2.x);
    }

    return dist;
}

// Bounding sphere distance
float sdBoundingSphere(vec3 p, vec4 sphere) {
    return length(p - sphere.xyz) - sphere.w;
}

// Apply CSG operation
float applyCSG(int op, float parentDist, float childDist, float smoothness) {
    if (op == CSG_UNION) return opUnion(parentDist, childDist);
    else if (op == CSG_SUBTRACTION) return opSubtraction(childDist, parentDist);
    else if (op == CSG_INTERSECTION) return opIntersection(parentDist, childDist);
    else if (op == CSG_SMOOTH_UNION) return opSmoothUnion(parentDist, childDist, smoothness);
    else if (op == CSG_SMOOTH_SUBTRACTION) return opSmoothSubtraction(childDist, parentDist, smoothness);
    else if (op == CSG_SMOOTH_INTERSECTION) return opSmoothIntersection(parentDist, childDist, smoothness);
    return parentDist;
}

// ===========================================================================
// Scene Evaluation
// ===========================================================================

struct SDFResult {
    float distance;
    int primitiveIndex;
    vec4 baseColor;
    vec4 material;
    vec4 emissiveColor;
};

SDFResult evaluateScene(vec3 p) {
    SDFResult result;
    result.distance = 1e10;
    result.primitiveIndex = -1;
    result.baseColor = vec4(1.0);
    result.material = vec4(0.0, 0.5, 0.0, 0.0);
    result.emissiveColor = vec4(0.0);

    if (u_primitiveCount == 0) return result;

    float closestDist = 1e10;
    int closestIdx = -1;

    for (int i = 0; i < u_primitiveCount; i++) {
        if (primitives[i].visible == 0) continue;

        // Early-out using bounding sphere
        float boundDist = sdBoundingSphere(p, primitives[i].boundingSphere);
        bool isRoot = (primitives[i].parentIndex == -1);
        int op = primitives[i].csgOperation;

        if (isRoot && boundDist > result.distance + 0.01) continue;
        if (!isRoot && (op == CSG_SUBTRACTION || op == CSG_SMOOTH_SUBTRACTION ||
                        op == CSG_INTERSECTION || op == CSG_SMOOTH_INTERSECTION)) {
            if (boundDist > result.distance + 1.0) continue;
        }

        float dist = evaluatePrimitive(primitives[i], p);
        float smoothness = primitives[i].parameters3.z;

        if (isRoot) {
            result.distance = opUnion(result.distance, dist);
        } else {
            result.distance = applyCSG(op, result.distance, dist, smoothness);
        }

        if (dist < closestDist) {
            closestDist = dist;
            closestIdx = i;
        }
    }

    if (closestIdx >= 0) {
        result.primitiveIndex = closestIdx;
        result.baseColor = primitives[closestIdx].baseColor;
        result.material = primitives[closestIdx].material;
        result.emissiveColor = primitives[closestIdx].emissiveColor;
    }

    return result;
}

// ===========================================================================
// Normal and Lighting
// ===========================================================================

vec3 calculateNormal(vec3 p) {
    const float eps = 0.001;
    return normalize(vec3(
        evaluateScene(p + vec3(eps, 0, 0)).distance - evaluateScene(p - vec3(eps, 0, 0)).distance,
        evaluateScene(p + vec3(0, eps, 0)).distance - evaluateScene(p - vec3(0, eps, 0)).distance,
        evaluateScene(p + vec3(0, 0, eps)).distance - evaluateScene(p - vec3(0, 0, eps)).distance
    ));
}

float calculateShadow(vec3 origin, vec3 direction, float minT, float maxT) {
    float res = 1.0;
    float t = minT;

    for (int i = 0; i < u_shadowSteps; i++) {
        float h = evaluateScene(origin + direction * t).distance;
        if (h < u_hitThreshold) return 0.0;
        res = min(res, u_shadowSoftness * h / t);
        t += h;
        if (t >= maxT) break;
    }

    return clamp(res, 0.0, 1.0);
}

float calculateAO(vec3 p, vec3 n) {
    float occ = 0.0;
    float sca = 1.0;

    for (int i = 0; i < u_aoSteps; i++) {
        float h = 0.01 + u_aoDistance * float(i) / float(u_aoSteps - 1);
        float d = evaluateScene(p + h * n).distance;
        occ += (h - d) * sca;
        sca *= 0.95;
    }

    return clamp(1.0 - u_aoIntensity * occ, 0.0, 1.0);
}

// ===========================================================================
// PBR Shading
// ===========================================================================

vec3 fresnelSchlick(float cosTheta, vec3 F0) {
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

float distributionGGX(vec3 N, vec3 H, float roughness) {
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float denom = (NdotH * NdotH * (a2 - 1.0) + 1.0);
    return a2 / (3.14159265359 * denom * denom);
}

float geometrySchlickGGX(float NdotV, float roughness) {
    float r = (roughness + 1.0);
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float geometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {
    return geometrySchlickGGX(max(dot(N, V), 0.0), roughness) *
           geometrySchlickGGX(max(dot(N, L), 0.0), roughness);
}

vec3 pbrShade(vec3 position, vec3 normal, vec3 viewDir, SDFResult hit) {
    vec3 albedo = hit.baseColor.rgb;
    float metallic = hit.material.x;
    float roughness = max(hit.material.y, 0.04);
    float emissive = hit.material.z;

    vec3 N = normal;
    vec3 V = viewDir;
    vec3 L = normalize(-u_lightDirection);
    vec3 H = normalize(V + L);

    vec3 F0 = mix(vec3(0.04), albedo, metallic);

    float NDF = distributionGGX(N, H, roughness);
    float G = geometrySmith(N, V, L, roughness);
    vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);

    vec3 specular = (NDF * G * F) / (4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.001);

    vec3 kD = (vec3(1.0) - F) * (1.0 - metallic);
    float NdotL = max(dot(N, L), 0.0);

    float shadow = 1.0;
    if (u_enableShadows != 0) {
        shadow = calculateShadow(position + normal * 0.01, L, 0.01, 50.0);
    }

    float ao = 1.0;
    if (u_enableAO != 0) {
        ao = calculateAO(position, normal);
    }

    vec3 radiance = u_lightColor * u_lightIntensity;
    vec3 Lo = (kD * albedo / 3.14159265359 + specular) * radiance * NdotL * shadow;
    vec3 ambient = vec3(0.03) * albedo * ao;

    vec3 color = ambient + Lo + hit.emissiveColor.rgb * emissive;

    // Tone mapping (Reinhard)
    color = color / (color + vec3(1.0));

    // Gamma correction
    color = pow(color, vec3(1.0 / 2.2));

    return color;
}

// ===========================================================================
// Main Compute Shader
// ===========================================================================

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    if (pixelCoord.x >= u_resolution.x || pixelCoord.y >= u_resolution.y) {
        return;
    }

    // Calculate UV and reconstruct ray
    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(u_resolution);
    vec2 ndc = uv * 2.0 - 1.0;

    vec4 clipPos = vec4(ndc.x, -ndc.y, -1.0, 1.0);
    vec4 worldNear = u_invView * (u_invProjection * clipPos);
    worldNear /= worldNear.w;

    clipPos.z = 1.0;
    vec4 worldFar = u_invView * (u_invProjection * clipPos);
    worldFar /= worldFar.w;

    vec3 rayOrigin = u_cameraPos;
    vec3 rayDir = normalize(worldFar.xyz - worldNear.xyz);

    // Raymarch
    float t = 0.01;
    vec3 finalColor = u_backgroundColor;

    for (int i = 0; i < u_maxSteps; i++) {
        vec3 p = rayOrigin + rayDir * t;
        SDFResult result = evaluateScene(p);

        if (result.distance < u_hitThreshold) {
            vec3 normal = calculateNormal(p);
            finalColor = pbrShade(p, normal, -rayDir, result);
            break;
        }

        t += result.distance;

        if (t > u_maxDistance) {
            break;
        }
    }

    imageStore(u_colorOutput, pixelCoord, vec4(finalColor, 1.0));
}
