#version 460 core

// Hybrid terrain GI compute shader
// Uses primary rasterization G-buffer + SDF raymarching for secondary rays

layout(local_size_x = 16, local_size_y = 16) in;

// Output GI result
layout(rgba16f, binding = 0) uniform image2D u_giOutput;

// Primary pass G-buffers
uniform sampler2D u_primaryColor;       // RGB: albedo, A: roughness
uniform sampler2D u_primaryNormal;      // RGB: world normal, A: metallic
uniform sampler2D u_primaryDepth;       // Depth buffer
uniform sampler2D u_primaryMaterial;    // Material ID

// Terrain SDF
uniform sampler3D u_terrainSDF;

// Radiance cascade textures (for GI)
uniform sampler3D u_radianceCascade0;
uniform sampler3D u_radianceCascade1;
uniform sampler3D u_radianceCascade2;
uniform sampler3D u_radianceCascade3;

// Camera uniforms
uniform mat4 u_invViewProj;
uniform vec3 u_cameraPos;
uniform vec2 u_resolution;

// Terrain uniforms
uniform vec3 u_terrainWorldMin;
uniform vec3 u_terrainWorldMax;
uniform int u_terrainResolution;

// Radiance cascade uniforms
uniform vec3 u_cascadeOrigin;
uniform float u_cascadeBaseSpacing;
uniform int u_numCascades;
uniform bool u_useRadianceCascades;

// Lighting
uniform vec3 u_sunDirection;
uniform vec3 u_sunColor;
uniform float u_sunIntensity;

// Quality settings
uniform int u_maxSteps;
uniform float u_maxDistance;
uniform bool u_enableShadows;
uniform bool u_enableAO;
uniform int u_giSamples;
uniform float u_shadowSoftness;

// Frame index for temporal variation
uniform int u_frameIndex;

// =============================================================================
// Utility Functions
// =============================================================================

// PCG random number generator
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

float random(inout uint seed) {
    seed = pcg_hash(seed);
    return float(seed) / 4294967296.0;
}

vec3 randomDirection(inout uint seed) {
    float theta = random(seed) * 6.28318530718;
    float phi = acos(2.0 * random(seed) - 1.0);
    float sinPhi = sin(phi);
    return vec3(sinPhi * cos(theta), sinPhi * sin(theta), cos(phi));
}

vec3 randomHemisphere(vec3 normal, inout uint seed) {
    vec3 dir = randomDirection(seed);
    return dot(dir, normal) > 0.0 ? dir : -dir;
}

// =============================================================================
// Depth Reconstruction
// =============================================================================

vec3 reconstructWorldPos(vec2 uv, float depth) {
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 worldPos = u_invViewProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

// =============================================================================
// SDF Sampling
// =============================================================================

float sampleTerrainSDF(vec3 worldPos) {
    vec3 uvw = (worldPos - u_terrainWorldMin) / (u_terrainWorldMax - u_terrainWorldMin);

    if (any(lessThan(uvw, vec3(0))) || any(greaterThan(uvw, vec3(1)))) {
        return 1000.0;  // Outside terrain bounds
    }

    return texture(u_terrainSDF, uvw).r;
}

vec3 calculateTerrainNormal(vec3 p) {
    const float eps = 0.5;
    float dx = sampleTerrainSDF(p + vec3(eps, 0, 0)) - sampleTerrainSDF(p - vec3(eps, 0, 0));
    float dy = sampleTerrainSDF(p + vec3(0, eps, 0)) - sampleTerrainSDF(p - vec3(0, eps, 0));
    float dz = sampleTerrainSDF(p + vec3(0, 0, eps)) - sampleTerrainSDF(p - vec3(0, 0, eps));
    return normalize(vec3(dx, dy, dz));
}

// =============================================================================
// Raymarching
// =============================================================================

struct RayHit {
    bool hit;
    vec3 position;
    vec3 normal;
    float distance;
};

RayHit raymarchTerrain(vec3 origin, vec3 direction, float maxDist) {
    RayHit result;
    result.hit = false;
    result.distance = 0.0;

    const float threshold = 0.01;
    float t = 0.01;  // Start slightly forward

    for (int i = 0; i < u_maxSteps; i++) {
        vec3 p = origin + direction * t;
        float dist = sampleTerrainSDF(p);

        if (dist < threshold) {
            result.hit = true;
            result.position = p;
            result.normal = calculateTerrainNormal(p);
            result.distance = t;
            return result;
        }

        t += max(dist * 0.9, 0.01);  // Conservative step

        if (t > maxDist) {
            break;
        }
    }

    return result;
}

// =============================================================================
// Radiance Cascade Sampling
// =============================================================================

vec3 sampleRadianceCascade(vec3 worldPos, vec3 normal, int cascadeLevel) {
    if (!u_useRadianceCascades) {
        return vec3(0.0);
    }

    float spacing = u_cascadeBaseSpacing * pow(2.0, float(cascadeLevel));
    vec3 uvw = (worldPos - u_cascadeOrigin) / spacing;
    uvw = uvw * 0.5 + 0.5;  // Map to [0,1]

    if (any(lessThan(uvw, vec3(0))) || any(greaterThan(uvw, vec3(1)))) {
        return vec3(0.0);
    }

    vec3 radiance = vec3(0.0);

    if (cascadeLevel == 0) {
        radiance = texture(u_radianceCascade0, uvw).rgb;
    } else if (cascadeLevel == 1) {
        radiance = texture(u_radianceCascade1, uvw).rgb;
    } else if (cascadeLevel == 2) {
        radiance = texture(u_radianceCascade2, uvw).rgb;
    } else {
        radiance = texture(u_radianceCascade3, uvw).rgb;
    }

    // Weight by normal alignment
    // Ideally would sample directional probes, but this is simplified
    return radiance * max(dot(normal, vec3(0, 1, 0)), 0.0);
}

vec3 sampleGlobalIllumination(vec3 worldPos, vec3 normal) {
    vec3 gi = vec3(0.0);

    // Sample from appropriate cascade level based on distance
    float distFromOrigin = length(worldPos - u_cascadeOrigin);

    for (int i = 0; i < min(u_numCascades, 4); i++) {
        float cascadeRange = u_cascadeBaseSpacing * pow(2.0, float(i + 1));

        if (distFromOrigin < cascadeRange) {
            vec3 cascadeGI = sampleRadianceCascade(worldPos, normal, i);
            float weight = 1.0 - smoothstep(0.5 * cascadeRange, cascadeRange, distFromOrigin);
            gi += cascadeGI * weight;
        }
    }

    return gi;
}

// =============================================================================
// Shadows
// =============================================================================

float calculateShadow(vec3 origin, vec3 direction) {
    if (!u_enableShadows) {
        return 1.0;
    }

    float res = 1.0;
    float t = 0.02;
    float maxT = u_maxDistance * 0.5;

    for (int i = 0; i < 32; i++) {
        vec3 p = origin + direction * t;
        float dist = sampleTerrainSDF(p);

        if (dist < 0.001) {
            return 0.0;  // In shadow
        }

        // Soft shadows
        res = min(res, u_shadowSoftness * dist / t);

        t += max(dist, 0.02);

        if (t > maxT) {
            break;
        }
    }

    return clamp(res, 0.0, 1.0);
}

// =============================================================================
// Ambient Occlusion
// =============================================================================

float calculateAO(vec3 p, vec3 n, inout uint seed) {
    if (!u_enableAO) {
        return 1.0;
    }

    float ao = 0.0;
    const int aoSamples = 8;
    const float aoRadius = 2.0;

    for (int i = 0; i < aoSamples; i++) {
        vec3 sampleDir = randomHemisphere(n, seed);
        float dist = random(seed) * aoRadius;
        vec3 samplePos = p + n * 0.01 + sampleDir * dist;

        float sdf = sampleTerrainSDF(samplePos);
        ao += smoothstep(-0.5, 0.5, sdf);
    }

    return ao / float(aoSamples);
}

// =============================================================================
// Main GI Computation
// =============================================================================

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);

    if (any(greaterThanEqual(pixel, ivec2(u_resolution)))) {
        return;
    }

    vec2 uv = (vec2(pixel) + 0.5) / u_resolution;

    // Sample G-buffer
    vec4 colorRoughness = texture(u_primaryColor, uv);
    vec4 normalMetallic = texture(u_primaryNormal, uv);
    float depth = texture(u_primaryDepth, uv).r;

    // Early exit for sky pixels
    if (depth >= 1.0) {
        imageStore(u_giOutput, pixel, vec4(0, 0, 0, 1));
        return;
    }

    // Reconstruct world position
    vec3 worldPos = reconstructWorldPos(uv, depth);
    vec3 normal = normalize(normalMetallic.xyz * 2.0 - 1.0);
    vec3 albedo = colorRoughness.rgb;
    float roughness = colorRoughness.a;
    float metallic = normalMetallic.a;

    // Initialize random seed
    uint seed = pcg_hash(pixel.x + pixel.y * 1920 + u_frameIndex * 1920 * 1080);

    // Direct lighting
    vec3 sunDir = normalize(-u_sunDirection);
    float NdotL = max(dot(normal, sunDir), 0.0);
    float shadow = calculateShadow(worldPos + normal * 0.05, sunDir);
    vec3 directLight = albedo * u_sunColor * u_sunIntensity * NdotL * shadow;

    // Global illumination from radiance cascades
    vec3 indirectDiffuse = sampleGlobalIllumination(worldPos, normal);

    // Ambient occlusion
    float ao = calculateAO(worldPos, normal, seed);

    // Monte Carlo GI sampling (optional, for higher quality)
    if (u_giSamples > 1) {
        vec3 giAccum = vec3(0.0);

        for (int i = 0; i < u_giSamples; i++) {
            vec3 randomDir = randomHemisphere(normal, seed);
            RayHit hit = raymarchTerrain(worldPos + normal * 0.05, randomDir, 10.0);

            if (hit.hit) {
                // Sample indirect light at hit point
                vec3 hitGI = sampleGlobalIllumination(hit.position, hit.normal);
                giAccum += hitGI * max(dot(normal, randomDir), 0.0);
            }
        }

        indirectDiffuse += giAccum / float(u_giSamples);
    }

    // Combine lighting
    vec3 finalColor = directLight + indirectDiffuse * albedo * ao;

    // Store result
    imageStore(u_giOutput, pixel, vec4(finalColor, 1.0));
}
