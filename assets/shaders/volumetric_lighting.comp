#version 460 core

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Output 3D volume texture
layout(rgba16f, binding = 0) uniform image3D u_volumeTexture;

// Input textures
uniform sampler2D u_shadowMap;
uniform sampler2D u_depthTexture;

// Uniforms
uniform mat4 u_invViewProj;
uniform mat4 u_lightViewProj;
uniform vec3 u_cameraPos;
uniform vec3 u_lightDir;
uniform vec3 u_lightColor;
uniform vec3 u_fogColor;

uniform ivec3 u_volumeDim;
uniform float u_nearPlane;
uniform float u_farPlane;
uniform int u_numSteps;
uniform float u_scattering;
uniform float u_absorption;
uniform float u_density;
uniform float u_jitterOffset;

const float PI = 3.14159265359;

// Phase function (Henyey-Greenstein)
float phaseFunction(float cosTheta, float g) {
    float g2 = g * g;
    float denom = 1.0 + g2 - 2.0 * g * cosTheta;
    return (1.0 - g2) / (4.0 * PI * pow(denom, 1.5));
}

// Sample shadow map
float sampleShadow(vec3 worldPos) {
    vec4 lightSpacePos = u_lightViewProj * vec4(worldPos, 1.0);
    vec3 projCoords = lightSpacePos.xyz / lightSpacePos.w;
    projCoords = projCoords * 0.5 + 0.5;

    if (projCoords.x < 0.0 || projCoords.x > 1.0 ||
        projCoords.y < 0.0 || projCoords.y > 1.0 ||
        projCoords.z > 1.0) {
        return 1.0;
    }

    float shadowDepth = texture(u_shadowMap, projCoords.xy).r;
    return projCoords.z - 0.005 < shadowDepth ? 1.0 : 0.0;
}

// Calculate inscattering
vec3 calculateInscattering(vec3 worldPos, vec3 viewDir) {
    float shadow = sampleShadow(worldPos);
    float cosTheta = dot(viewDir, -u_lightDir);
    float phase = phaseFunction(cosTheta, 0.76); // g = 0.76 for atmospheric scattering

    vec3 inscatter = u_lightColor * u_scattering * phase * shadow;
    inscatter += u_fogColor * 0.02; // Ambient fog

    return inscatter * u_density;
}

// Exponential depth distribution
float getDepthForSlice(int slice) {
    float ratio = float(slice) / float(u_volumeDim.z);
    return u_nearPlane * pow(u_farPlane / u_nearPlane, ratio);
}

void main() {
    ivec3 voxelCoord = ivec3(gl_GlobalInvocationID.xyz);

    if (voxelCoord.x >= u_volumeDim.x ||
        voxelCoord.y >= u_volumeDim.y ||
        voxelCoord.z >= u_volumeDim.z) {
        return;
    }

    // Calculate UV and depth for this voxel
    vec2 uv = (vec2(voxelCoord.xy) + 0.5) / vec2(u_volumeDim.xy);
    float depth = getDepthForSlice(voxelCoord.z);

    // Reconstruct world position
    vec4 clipPos = vec4(uv * 2.0 - 1.0, depth, 1.0);
    vec4 worldPos4 = u_invViewProj * clipPos;
    vec3 worldPos = worldPos4.xyz / worldPos4.w;

    // View direction
    vec3 viewDir = normalize(worldPos - u_cameraPos);

    // Add temporal jitter to reduce banding
    float jitter = u_jitterOffset;
    worldPos += viewDir * jitter;

    // Calculate inscattering
    vec3 inscatter = calculateInscattering(worldPos, viewDir);

    // Transmittance (Beer-Lambert law)
    float stepSize = (depth - getDepthForSlice(max(0, voxelCoord.z - 1))) / float(u_numSteps);
    float transmittance = exp(-u_absorption * stepSize);

    // Store result
    vec4 result = vec4(inscatter, transmittance);
    imageStore(u_volumeTexture, voxelCoord, result);
}
