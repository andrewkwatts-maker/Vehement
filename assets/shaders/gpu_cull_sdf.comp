#version 450 core

// GPU-driven culling compute shader for 10,000+ SDF instances
// Performs frustum culling and generates indirect draw commands

layout(local_size_x = 256) in;

// ============================================================================
// Structures
// ============================================================================

struct Instance {
    mat4 transform;
    vec4 boundingSphere;  // xyz = center, w = radius
    uint materialID;
    uint lodLevel;
    uint instanceID;
    uint flags;
};

struct DrawCommand {
    uint vertexCount;
    uint instanceCount;
    uint firstVertex;
    uint baseVertex;
    uint baseInstance;
};

// ============================================================================
// Buffers
// ============================================================================

layout(std430, binding = 0) readonly buffer InstanceBuffer {
    Instance instances[];
};

layout(std430, binding = 1) writeonly buffer VisibleInstanceBuffer {
    uint visibleInstances[];
};

layout(std430, binding = 2) buffer DrawCommandBuffer {
    DrawCommand drawCommands[];
};

layout(std430, binding = 3) buffer CounterBuffer {
    uint visibleCount;
    uint drawCommandCount;
    uint padding1;
    uint padding2;
};

// ============================================================================
// Uniforms
// ============================================================================

layout(binding = 0) uniform FrustumPlanes {
    vec4 planes[6];  // Left, right, bottom, top, near, far
};

uniform mat4 u_viewProj;
uniform uint u_instanceCount;
uniform float u_nearPlane;
uniform float u_farPlane;
uniform vec3 u_cameraPos;

// ============================================================================
// Functions
// ============================================================================

bool FrustumCullSphere(vec3 center, float radius) {
    for (int i = 0; i < 6; i++) {
        float distance = dot(planes[i].xyz, center) + planes[i].w;
        if (distance < -radius) {
            return false;  // Outside frustum
        }
    }
    return true;  // Inside or intersecting
}

uint CalculateLOD(vec3 worldPos, float boundingRadius) {
    float distance = length(worldPos - u_cameraPos);

    // Screen-space size estimation
    float fovFactor = 2.0 / (u_farPlane - u_nearPlane);
    float projectedSize = (boundingRadius * fovFactor) / distance;

    // Determine LOD level based on projected size
    if (projectedSize > 0.3) return 0;      // Highest detail
    else if (projectedSize > 0.15) return 1;
    else if (projectedSize > 0.075) return 2;
    else if (projectedSize > 0.0375) return 3;
    else return 4;  // Lowest detail
}

bool OcclusionCull(vec3 center, float radius) {
    // Placeholder for Hi-Z occlusion culling
    // Would sample from Hi-Z buffer here
    return true;  // Not occluded
}

// ============================================================================
// Main Kernel
// ============================================================================

void main() {
    uint idx = gl_GlobalInvocationID.x;

    if (idx >= u_instanceCount) {
        return;
    }

    Instance inst = instances[idx];

    // Transform bounding sphere center to world space
    vec4 worldCenter4 = inst.transform * vec4(inst.boundingSphere.xyz, 1.0);
    vec3 worldCenter = worldCenter4.xyz;
    float radius = inst.boundingSphere.w;

    // Frustum culling
    if (!FrustumCullSphere(worldCenter, radius)) {
        return;  // Culled
    }

    // Occlusion culling (optional)
    if (!OcclusionCull(worldCenter, radius)) {
        return;  // Occluded
    }

    // Calculate LOD level
    uint lod = CalculateLOD(worldCenter, radius);

    // Instance is visible - add to visible list
    uint visibleIndex = atomicAdd(visibleCount, 1);

    if (visibleIndex < instances.length()) {
        visibleInstances[visibleIndex] = idx;
    }

    // Update LOD in instance (for later use)
    // Note: This modifies the instance buffer, remove if read-only
    // instances[idx].lodLevel = lod;
}

// ============================================================================
// Alternative: Generate Draw Commands Directly
// ============================================================================

/*
// This variant generates draw commands grouped by material/LOD
// Call with one thread per material batch

layout(local_size_x = 1) in;

void main() {
    uint materialID = gl_GlobalInvocationID.x;

    // Count instances for this material
    uint instanceCount = 0;

    for (uint i = 0; i < u_instanceCount; i++) {
        Instance inst = instances[i];

        if (inst.materialID != materialID) {
            continue;
        }

        // Transform bounding sphere
        vec4 worldCenter4 = inst.transform * vec4(inst.boundingSphere.xyz, 1.0);
        vec3 worldCenter = worldCenter4.xyz;
        float radius = inst.boundingSphere.w;

        // Frustum culling
        if (!FrustumCullSphere(worldCenter, radius)) {
            continue;
        }

        instanceCount++;
    }

    // Generate draw command if instances are visible
    if (instanceCount > 0) {
        uint cmdIndex = atomicAdd(drawCommandCount, 1);

        DrawCommand cmd;
        cmd.vertexCount = 36;  // Cube
        cmd.instanceCount = instanceCount;
        cmd.firstVertex = 0;
        cmd.baseVertex = 0;
        cmd.baseInstance = cmdIndex * 10000;  // Offset per batch

        drawCommands[cmdIndex] = cmd;
    }
}
*/

// ============================================================================
// Performance Notes:
// ============================================================================
//
// - Thread group size of 256 is optimal for most GPUs
// - 10,000 instances = 40 workgroups
// - Expected performance: <0.5ms on modern GPUs
//
// Optimizations:
// - Use shared memory for frustum planes (loaded once per workgroup)
// - Early exit on first failed plane test
// - Batch atomic operations (use local counters, then global atomic)
// - Use wave intrinsics for ballot/reduce operations
//
