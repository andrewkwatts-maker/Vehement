#version 460 core
layout(local_size_x = 8, local_size_y = 8) in;

// ============================================================================
// ReSTIR Spatial Reuse Pass
// ============================================================================
// Shares light samples between neighboring pixels. Since similar surfaces
// benefit from similar lighting, we can merge reservoirs from nearby pixels
// to dramatically increase effective sample count.
//
// Process (per pixel):
// 1. Sample N neighbors within a radius (typically 5-10 samples, 30px radius)
// 2. For each neighbor, check surface similarity (normal, depth)
// 3. Merge neighbor's reservoir with current pixel's reservoir
// 4. Repeat for multiple iterations (typically 3) for better distribution
//
// This turns 32 samples into 32*20*5*3 = 9,600 effective samples!
// ============================================================================

// Reservoir structure
struct Reservoir {
    int lightIndex;
    float weightSum;
    float W;
    int M;
    vec3 padding;
};

// Light structure
struct GPULight {
    vec4 position;
    vec4 direction;
    vec4 color;
    vec4 params;
};

// Input G-buffers
layout(rgba32f, binding = 0) uniform image2D u_gBufferPosition;
layout(rgba16f, binding = 1) uniform image2D u_gBufferNormal;
layout(r32f, binding = 2) uniform image2D u_gBufferDepth;

// Reservoir buffers (ping-pong)
layout(std430, binding = 0) buffer ReservoirBufferIn {
    Reservoir inputReservoirs[];
};

layout(std430, binding = 1) buffer ReservoirBufferOut {
    Reservoir outputReservoirs[];
};

// Light data
layout(std430, binding = 2) buffer LightBuffer {
    GPULight lights[];
};

// Uniforms
uniform int u_frameCount = 0;
uniform vec2 u_resolution = vec2(1920.0, 1080.0);
uniform float u_spatialRadius = 30.0;
uniform int u_spatialSamples = 5;
uniform bool u_discardHistory = false;

// Similarity thresholds
const float DEPTH_THRESHOLD = 0.1;
const float NORMAL_THRESHOLD = 0.9;
const float PLANE_DISTANCE_THRESHOLD = 0.05;

// ============================================================================
// Random Number Generation
// ============================================================================

uint g_rngState;

void InitRNG(ivec2 pixelCoord, int frame) {
    uint seed = uint(pixelCoord.x) + uint(pixelCoord.y) * 8192u + uint(frame) * 65536u;
    g_rngState = seed * 747796405u + 2891336453u;
}

float Random01() {
    g_rngState = g_rngState * 747796405u + 2891336453u;
    uint word = ((g_rngState >> ((g_rngState >> 28u) + 4u)) ^ g_rngState) * 277803737u;
    return float((word >> 22u) ^ word) / 4294967296.0;
}

// ============================================================================
// Light Evaluation
// ============================================================================

vec3 EvaluateLight(GPULight light, vec3 position, vec3 normal, vec3 albedo) {
    int lightType = int(light.params.y);

    if (lightType == 0) {  // Point light
        vec3 lightDir = light.position.xyz - position;
        float dist = length(lightDir);
        if (dist > light.position.w) return vec3(0.0);

        lightDir /= dist;
        float NdotL = max(dot(normal, lightDir), 0.0);
        if (NdotL < 0.001) return vec3(0.0);

        float attenuation = 1.0 / (dist * dist + 1.0);
        float rangeFalloff = 1.0 - smoothstep(light.position.w * 0.8, light.position.w, dist);
        return light.color.rgb * light.color.a * NdotL * attenuation * rangeFalloff * albedo;

    } else if (lightType == 1) {  // Spot light
        vec3 lightDir = light.position.xyz - position;
        float dist = length(lightDir);
        if (dist > light.position.w) return vec3(0.0);

        lightDir /= dist;
        float NdotL = max(dot(normal, lightDir), 0.0);
        if (NdotL < 0.001) return vec3(0.0);

        float spotAngle = dot(-lightDir, normalize(light.direction.xyz));
        float innerCone = cos(light.direction.w);
        float outerCone = cos(light.params.x);
        float spotFalloff = smoothstep(outerCone, innerCone, spotAngle);
        if (spotFalloff < 0.001) return vec3(0.0);

        float attenuation = 1.0 / (dist * dist + 1.0);
        float rangeFalloff = 1.0 - smoothstep(light.position.w * 0.8, light.position.w, dist);
        return light.color.rgb * light.color.a * NdotL * attenuation * rangeFalloff * spotFalloff * albedo;

    } else if (lightType == 2) {  // Directional light
        vec3 lightDir = -normalize(light.direction.xyz);
        float NdotL = max(dot(normal, lightDir), 0.0);
        if (NdotL < 0.001) return vec3(0.0);
        return light.color.rgb * light.color.a * NdotL * albedo;
    }

    return vec3(0.0);
}

float ContributionToWeight(vec3 contribution) {
    return dot(contribution, vec3(0.2126, 0.7152, 0.0722));
}

// ============================================================================
// Surface Similarity Tests
// ============================================================================

// Check if two surfaces are similar enough for spatial reuse
bool IsSimilarSurface(vec3 centerPos, vec3 centerNormal, float centerDepth,
                      vec3 neighborPos, vec3 neighborNormal, float neighborDepth) {
    // Normal similarity (most important)
    float normalSimilarity = dot(centerNormal, neighborNormal);
    if (normalSimilarity < NORMAL_THRESHOLD) return false;

    // Depth similarity
    float depthDiff = abs(centerDepth - neighborDepth);
    if (depthDiff > DEPTH_THRESHOLD) return false;

    // Plane-distance test (reject if neighbor is too far from center's plane)
    vec3 centerToNeighbor = neighborPos - centerPos;
    float planeDistance = abs(dot(centerToNeighbor, centerNormal));
    if (planeDistance > PLANE_DISTANCE_THRESHOLD) return false;

    return true;
}

// ============================================================================
// Reservoir Operations
// ============================================================================

void MergeReservoirs(inout Reservoir dst, Reservoir src, vec3 dstPosition, vec3 dstNormal, vec3 dstAlbedo) {
    if (src.M == 0 || src.lightIndex < 0) return;

    // Revalidate source's light for destination's surface
    GPULight srcLight = lights[src.lightIndex];
    vec3 contribution = EvaluateLight(srcLight, dstPosition, dstNormal, dstAlbedo);
    float targetPdf = ContributionToWeight(contribution);

    // Compute merge weight
    // Note: In spatial reuse, we can optionally discard M history to reduce bias
    int effectiveM = u_discardHistory ? 1 : src.M;
    float mergeWeight = src.W * float(effectiveM) * targetPdf;

    // Update reservoir
    dst.weightSum += mergeWeight;
    dst.M += effectiveM;

    // Probabilistic selection
    if (Random01() < mergeWeight / max(dst.weightSum, 0.0001)) {
        dst.lightIndex = src.lightIndex;
    }
}

void FinalizeReservoir(inout Reservoir r, vec3 position, vec3 normal, vec3 albedo) {
    if (r.M == 0 || r.lightIndex < 0) {
        r.W = 0.0;
        return;
    }

    // Recompute target PDF
    GPULight selectedLight = lights[r.lightIndex];
    vec3 contribution = EvaluateLight(selectedLight, position, normal, albedo);
    float targetPdf = ContributionToWeight(contribution);

    // Compute W
    r.W = (r.weightSum / float(r.M)) / max(targetPdf, 0.0001);
}

// ============================================================================
// Spatial Sampling
// ============================================================================

// Generate uniformly distributed point on disk (for spatial sampling)
vec2 SampleDisk(float radius) {
    float angle = Random01() * 6.28318530718; // 2 * PI
    float r = sqrt(Random01()) * radius;
    return vec2(cos(angle) * r, sin(angle) * r);
}

// ============================================================================
// Main Compute Shader
// ============================================================================

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);

    // Bounds check
    if (pixelCoord.x >= int(u_resolution.x) || pixelCoord.y >= int(u_resolution.y)) return;

    // Initialize RNG
    InitRNG(pixelCoord, u_frameCount);

    // Load center pixel data
    vec3 centerPos = imageLoad(u_gBufferPosition, pixelCoord).xyz;
    vec3 centerNormal = imageLoad(u_gBufferNormal, pixelCoord).xyz;
    float centerDepth = imageLoad(u_gBufferDepth, pixelCoord).r;

    // Early out for sky/background
    if (length(centerNormal) < 0.1) {
        int bufferIdx = pixelCoord.y * int(u_resolution.x) + pixelCoord.x;
        outputReservoirs[bufferIdx] = inputReservoirs[bufferIdx];
        return;
    }

    centerNormal = normalize(centerNormal);

    // Load center's input reservoir
    int centerIdx = pixelCoord.y * int(u_resolution.x) + pixelCoord.x;
    Reservoir centerReservoir = inputReservoirs[centerIdx];

    // Spatial reuse: sample neighbors and merge their reservoirs
    for (int i = 0; i < u_spatialSamples; i++) {
        // Generate random neighbor position (disk sampling)
        vec2 offset = SampleDisk(u_spatialRadius);
        ivec2 neighborCoord = pixelCoord + ivec2(offset);

        // Bounds check
        if (neighborCoord.x < 0 || neighborCoord.x >= int(u_resolution.x) ||
            neighborCoord.y < 0 || neighborCoord.y >= int(u_resolution.y)) {
            continue;
        }

        // Load neighbor data
        vec3 neighborPos = imageLoad(u_gBufferPosition, neighborCoord).xyz;
        vec3 neighborNormal = imageLoad(u_gBufferNormal, neighborCoord).xyz;
        float neighborDepth = imageLoad(u_gBufferDepth, neighborCoord).r;

        // Skip if background
        if (length(neighborNormal) < 0.1) continue;

        neighborNormal = normalize(neighborNormal);

        // Test surface similarity
        if (!IsSimilarSurface(centerPos, centerNormal, centerDepth,
                             neighborPos, neighborNormal, neighborDepth)) {
            continue;
        }

        // Load neighbor's reservoir
        int neighborIdx = neighborCoord.y * int(u_resolution.x) + neighborCoord.x;
        Reservoir neighborReservoir = inputReservoirs[neighborIdx];

        // Merge neighbor's reservoir with center
        MergeReservoirs(centerReservoir, neighborReservoir, centerPos, centerNormal, vec3(1.0));
    }

    // Finalize combined reservoir
    FinalizeReservoir(centerReservoir, centerPos, centerNormal, vec3(1.0));

    // Store result
    outputReservoirs[centerIdx] = centerReservoir;
}
