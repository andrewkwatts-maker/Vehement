#include "StandaloneEditor.hpp"
#include "core/Engine.hpp"
#include "core/Window.hpp"
#include "graphics/Renderer.hpp"
#include "graphics/debug/DebugDraw.hpp"
#include "input/InputManager.hpp"

#include <imgui.h>
#include <spdlog/spdlog.h>
#include <algorithm>

StandaloneEditor::StandaloneEditor() = default;
StandaloneEditor::~StandaloneEditor() = default;

bool StandaloneEditor::Initialize() {
    if (m_initialized) {
        return true;
    }

    spdlog::info("Initializing Standalone Editor");

    // Apply custom theme
    ApplyEditorTheme();

    // Setup default panel layout
    SetupDefaultLayout();

    // Create default map
    NewMap(m_mapWidth, m_mapHeight);

    m_initialized = true;
    spdlog::info("Standalone Editor initialized");
    return true;
}

void StandaloneEditor::SetupDefaultLayout() {
    m_panelLayouts.clear();

    // Default layout:
    // - Viewport: Center (fills remaining space)
    // - Tools: Left side
    // - Content Browser: Bottom
    // - Details: Right side
    // - Material Editor: Floating (hidden by default)
    // - Engine Stats: Floating (shown if debug enabled)

    m_panelLayouts.push_back({PanelID::Viewport, DockZone::Center, 1.0f, true});
    m_panelLayouts.push_back({PanelID::Tools, DockZone::Left, 1.0f, true});
    m_panelLayouts.push_back({PanelID::ContentBrowser, DockZone::Bottom, 1.0f, true});
    m_panelLayouts.push_back({PanelID::Details, DockZone::Right, 1.0f, true});
    m_panelLayouts.push_back({PanelID::MaterialEditor, DockZone::Floating, 1.0f, false});
    m_panelLayouts.push_back({PanelID::EngineStats, DockZone::Floating, 1.0f, false});
}

void StandaloneEditor::ApplyEditorTheme() {
    ImGuiStyle& style = ImGui::GetStyle();
    ImVec4* colors = style.Colors;

    // Inspired by mystical dark theme with gold/purple/blue accents
    // Base colors - deep dark with slight warmth
    colors[ImGuiCol_Text]                   = ImVec4(0.95f, 0.95f, 0.98f, 1.00f);
    colors[ImGuiCol_TextDisabled]           = ImVec4(0.50f, 0.50f, 0.55f, 1.00f);
    colors[ImGuiCol_WindowBg]               = ImVec4(0.08f, 0.08f, 0.12f, 0.95f);
    colors[ImGuiCol_ChildBg]                = ImVec4(0.10f, 0.10f, 0.14f, 0.90f);
    colors[ImGuiCol_PopupBg]                = ImVec4(0.10f, 0.10f, 0.15f, 0.95f);

    // Borders - subtle gold glow
    colors[ImGuiCol_Border]                 = ImVec4(0.60f, 0.50f, 0.20f, 0.40f);
    colors[ImGuiCol_BorderShadow]           = ImVec4(0.00f, 0.00f, 0.00f, 0.50f);

    // Frame backgrounds - nested panels
    colors[ImGuiCol_FrameBg]                = ImVec4(0.15f, 0.15f, 0.20f, 0.85f);
    colors[ImGuiCol_FrameBgHovered]         = ImVec4(0.25f, 0.20f, 0.35f, 0.90f);  // Purple tint
    colors[ImGuiCol_FrameBgActive]          = ImVec4(0.30f, 0.25f, 0.45f, 0.95f);

    // Title bars - gold gradient feeling
    colors[ImGuiCol_TitleBg]                = ImVec4(0.15f, 0.12f, 0.08f, 1.00f);
    colors[ImGuiCol_TitleBgActive]          = ImVec4(0.35f, 0.28f, 0.12f, 1.00f);  // Gold
    colors[ImGuiCol_TitleBgCollapsed]       = ImVec4(0.12f, 0.10f, 0.08f, 0.85f);

    // Menu bar
    colors[ImGuiCol_MenuBarBg]              = ImVec4(0.12f, 0.12f, 0.16f, 1.00f);

    // Scrollbar
    colors[ImGuiCol_ScrollbarBg]            = ImVec4(0.10f, 0.10f, 0.14f, 0.90f);
    colors[ImGuiCol_ScrollbarGrab]          = ImVec4(0.40f, 0.35f, 0.20f, 0.80f);
    colors[ImGuiCol_ScrollbarGrabHovered]   = ImVec4(0.55f, 0.48f, 0.25f, 0.90f);
    colors[ImGuiCol_ScrollbarGrabActive]    = ImVec4(0.70f, 0.60f, 0.30f, 1.00f);

    // Check marks and sliders - cyan accent
    colors[ImGuiCol_CheckMark]              = ImVec4(0.00f, 0.80f, 0.82f, 1.00f);  // Cyan
    colors[ImGuiCol_SliderGrab]             = ImVec4(0.50f, 0.45f, 0.25f, 1.00f);
    colors[ImGuiCol_SliderGrabActive]       = ImVec4(0.75f, 0.65f, 0.35f, 1.00f);

    // Buttons - purple/blue gradient feeling
    colors[ImGuiCol_Button]                 = ImVec4(0.25f, 0.20f, 0.35f, 0.80f);  // Purple
    colors[ImGuiCol_ButtonHovered]          = ImVec4(0.35f, 0.28f, 0.50f, 0.90f);
    colors[ImGuiCol_ButtonActive]           = ImVec4(0.45f, 0.35f, 0.65f, 1.00f);

    // Headers - collapsible sections
    colors[ImGuiCol_Header]                 = ImVec4(0.28f, 0.23f, 0.38f, 0.75f);
    colors[ImGuiCol_HeaderHovered]          = ImVec4(0.35f, 0.28f, 0.48f, 0.85f);
    colors[ImGuiCol_HeaderActive]           = ImVec4(0.42f, 0.33f, 0.58f, 0.95f);

    // Separators
    colors[ImGuiCol_Separator]              = ImVec4(0.50f, 0.45f, 0.25f, 0.30f);
    colors[ImGuiCol_SeparatorHovered]       = ImVec4(0.65f, 0.58f, 0.32f, 0.50f);
    colors[ImGuiCol_SeparatorActive]        = ImVec4(0.80f, 0.70f, 0.40f, 0.70f);

    // Resize grip
    colors[ImGuiCol_ResizeGrip]             = ImVec4(0.40f, 0.35f, 0.20f, 0.40f);
    colors[ImGuiCol_ResizeGripHovered]      = ImVec4(0.55f, 0.48f, 0.25f, 0.60f);
    colors[ImGuiCol_ResizeGripActive]       = ImVec4(0.70f, 0.60f, 0.30f, 0.90f);

    // Tabs
    colors[ImGuiCol_Tab]                    = ImVec4(0.18f, 0.15f, 0.12f, 0.90f);
    colors[ImGuiCol_TabHovered]             = ImVec4(0.38f, 0.30f, 0.15f, 0.95f);
    colors[ImGuiCol_TabActive]              = ImVec4(0.35f, 0.28f, 0.12f, 1.00f);
    colors[ImGuiCol_TabUnfocused]           = ImVec4(0.15f, 0.12f, 0.10f, 0.85f);
    colors[ImGuiCol_TabUnfocusedActive]     = ImVec4(0.25f, 0.20f, 0.10f, 0.90f);

    // Table
    colors[ImGuiCol_TableHeaderBg]          = ImVec4(0.20f, 0.18f, 0.15f, 1.00f);
    colors[ImGuiCol_TableBorderStrong]      = ImVec4(0.45f, 0.40f, 0.22f, 1.00f);
    colors[ImGuiCol_TableBorderLight]       = ImVec4(0.30f, 0.27f, 0.18f, 1.00f);
    colors[ImGuiCol_TableRowBg]             = ImVec4(0.00f, 0.00f, 0.00f, 0.00f);
    colors[ImGuiCol_TableRowBgAlt]          = ImVec4(1.00f, 1.00f, 1.00f, 0.03f);

    // Text selection
    colors[ImGuiCol_TextSelectedBg]         = ImVec4(0.45f, 0.35f, 0.60f, 0.45f);

    // Drag and drop
    colors[ImGuiCol_DragDropTarget]         = ImVec4(0.00f, 0.80f, 0.82f, 0.90f);  // Cyan

    // Nav highlight
    colors[ImGuiCol_NavHighlight]           = ImVec4(0.65f, 0.55f, 0.30f, 1.00f);
    colors[ImGuiCol_NavWindowingHighlight]  = ImVec4(1.00f, 1.00f, 1.00f, 0.70f);
    colors[ImGuiCol_NavWindowingDimBg]      = ImVec4(0.80f, 0.80f, 0.80f, 0.20f);

    // Modal
    colors[ImGuiCol_ModalWindowDimBg]       = ImVec4(0.10f, 0.10f, 0.15f, 0.60f);

    // Style adjustments - more compact
    style.WindowPadding                     = ImVec2(8, 8);
    style.FramePadding                      = ImVec2(5, 3);
    style.CellPadding                       = ImVec2(4, 2);
    style.ItemSpacing                       = ImVec2(8, 4);
    style.ItemInnerSpacing                  = ImVec2(4, 4);
    style.TouchExtraPadding                 = ImVec2(0, 0);
    style.IndentSpacing                     = 18;
    style.ScrollbarSize                     = 14;
    style.GrabMinSize                       = 10;

    // Borders and rounding - subtle glow effect
    style.WindowBorderSize                  = 1;
    style.ChildBorderSize                   = 1;
    style.PopupBorderSize                   = 1;
    style.FrameBorderSize                   = 1;
    style.TabBorderSize                     = 0;

    style.WindowRounding                    = 6;
    style.ChildRounding                     = 4;
    style.FrameRounding                     = 4;
    style.PopupRounding                     = 4;
    style.ScrollbarRounding                 = 8;
    style.GrabRounding                      = 4;
    style.LogSliderDeadzone                 = 4;
    style.TabRounding                       = 4;

    // Window title alignment
    style.WindowTitleAlign                  = ImVec2(0.5f, 0.5f);
    style.WindowMenuButtonPosition          = ImGuiDir_Right;
    style.ColorButtonPosition               = ImGuiDir_Right;

    // Misc
    style.Alpha                             = 1.0f;
    style.DisabledAlpha                     = 0.5f;
    style.AntiAliasedLines                  = true;
    style.AntiAliasedLinesUseTex            = true;
    style.AntiAliasedFill                   = true;
}

void StandaloneEditor::Shutdown() {
    spdlog::info("Shutting down Standalone Editor");
    m_initialized = false;
}

void StandaloneEditor::Update(float deltaTime) {
    if (!m_initialized) {
        return;
    }

    // Update camera
    auto& input = Nova::Engine::Instance().GetInput();

    // Camera rotation with arrow keys
    if (input.IsKeyDown(Nova::Key::Left)) {
        m_cameraAngle -= deltaTime * 90.0f;
    }
    if (input.IsKeyDown(Nova::Key::Right)) {
        m_cameraAngle += deltaTime * 90.0f;
    }

    // Camera zoom with Page Up/Down
    if (input.IsKeyDown(Nova::Key::PageUp)) {
        m_cameraDistance = std::max(5.0f, m_cameraDistance - deltaTime * 20.0f);
    }
    if (input.IsKeyDown(Nova::Key::PageDown)) {
        m_cameraDistance = std::min(100.0f, m_cameraDistance + deltaTime * 20.0f);
    }

    // Calculate camera position
    float rad = glm::radians(m_cameraAngle);
    m_editorCameraPos.x = m_cameraDistance * cos(rad);
    m_editorCameraPos.z = m_cameraDistance * sin(rad);
    m_editorCameraPos.y = m_cameraDistance * 0.7f;
}

void StandaloneEditor::RenderUI() {
    // Render menu bar
    if (ImGui::BeginMainMenuBar()) {
        if (ImGui::BeginMenu("File")) {
            if (ImGui::MenuItem("New Map", "Ctrl+N")) {
                m_showNewMapDialog = true;
            }
            if (ImGui::MenuItem("Open Map", "Ctrl+O")) {
                m_showLoadMapDialog = true;
            }
            if (ImGui::MenuItem("Save Map", "Ctrl+S")) {
                if (!m_currentMapPath.empty()) {
                    SaveMap(m_currentMapPath);
                } else {
                    m_showSaveMapDialog = true;
                }
            }
            if (ImGui::MenuItem("Save Map As", "Ctrl+Shift+S")) {
                m_showSaveMapDialog = true;
            }
            ImGui::Separator();
            if (ImGui::MenuItem("Exit Editor", "Esc")) {
                // Will be handled by RTSApplication
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Edit")) {
            if (ImGui::MenuItem("Undo", "Ctrl+Z", false, false)) {}
            if (ImGui::MenuItem("Redo", "Ctrl+Y", false, false)) {}
            ImGui::Separator();
            if (ImGui::MenuItem("Map Properties")) {}
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("View")) {
            // Toggle panel visibility
            for (auto& layout : m_panelLayouts) {
                ImGui::MenuItem(GetPanelName(layout.id), nullptr, &layout.isVisible);
            }
            ImGui::Separator();
            ImGui::MenuItem("Show Grid", nullptr, &m_showGrid);
            ImGui::MenuItem("Show Gizmos", nullptr, &m_showGizmos);
            ImGui::MenuItem("Snap to Grid", nullptr, &m_snapToGrid);
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Tools")) {
            if (ImGui::MenuItem("Terrain Editor", nullptr, m_editMode == EditMode::TerrainPaint)) {
                SetEditMode(EditMode::TerrainPaint);
            }
            if (ImGui::MenuItem("Object Placement", nullptr, m_editMode == EditMode::ObjectPlace)) {
                SetEditMode(EditMode::ObjectPlace);
            }
            if (ImGui::MenuItem("Material Editor", nullptr, m_editMode == EditMode::MaterialEdit)) {
                SetEditMode(EditMode::MaterialEdit);
                // Show material editor as floating window
                for (auto& layout : m_panelLayouts) {
                    if (layout.id == PanelID::MaterialEditor) {
                        layout.isVisible = true;
                        break;
                    }
                }
            }
            ImGui::EndMenu();
        }

        if (ImGui::BeginMenu("Help")) {
            if (ImGui::MenuItem("About")) {
                m_showAboutDialog = true;
            }
            ImGui::EndMenu();
        }

        // Stats display on the right side of menu bar
        float menuBarHeight = ImGui::GetFrameHeight();
        float statsWidth = 200.0f;
        ImGui::SameLine(ImGui::GetWindowWidth() - statsWidth - 10);

        // FPS display (always visible)
        ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);

        // Expandable stats dropdown
        ImGui::SameLine();
        if (ImGui::BeginMenu("Stats")) {
            ImGui::Text("Performance");
            ImGui::Separator();
            ImGui::Text("Frame Time: %.3f ms", 1000.0f / ImGui::GetIO().Framerate);
            ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);

            ImGui::Separator();
            ImGui::Text("Debug Overlays");
            static bool showDebugOverlay = false;
            static bool showProfiler = false;
            static bool showMemory = false;
            ImGui::Checkbox("Show Debug Overlay", &showDebugOverlay);
            ImGui::Checkbox("Show Profiler", &showProfiler);
            ImGui::Checkbox("Show Memory Stats", &showMemory);

            ImGui::Separator();
            ImGui::Text("Time Distribution");
            static bool showRenderTime = false;
            static bool showUpdateTime = false;
            static bool showPhysicsTime = false;
            ImGui::Checkbox("Render Time", &showRenderTime);
            ImGui::Checkbox("Update Time", &showUpdateTime);
            ImGui::Checkbox("Physics Time", &showPhysicsTime);

            ImGui::EndMenu();
        }

        ImGui::EndMainMenuBar();
    }

    // Render docking layout system
    RenderDockingLayout();

    // Dialogs (always on top)
    if (m_showNewMapDialog) ShowNewMapDialog();
    if (m_showLoadMapDialog) ShowLoadMapDialog();
    if (m_showSaveMapDialog) ShowSaveMapDialog();
    if (m_showAboutDialog) ShowAboutDialog();
}

void StandaloneEditor::Render3D(Nova::Renderer& renderer, const Nova::Camera& camera) {
    if (!m_initialized) {
        return;
    }

    auto& debugDraw = renderer.GetDebugDraw();

    // Draw grid if enabled
    if (m_showGrid) {
        debugDraw.AddGrid(m_mapWidth, m_gridSize, glm::vec4(0.5f, 0.5f, 0.5f, 0.5f));
    }

    // Draw terrain tiles (simple colored quads for now)
    for (int y = 0; y < m_mapHeight; ++y) {
        for (int x = 0; x < m_mapWidth; ++x) {
            int index = y * m_mapWidth + x;
            float height = m_terrainHeights[index];

            glm::vec3 pos(x * m_gridSize, height, y * m_gridSize);
            glm::vec4 color(0.2f, 0.6f, 0.2f, 1.0f); // Green for grass

            // Simple tile visualization
            debugDraw.AddAABB(pos, glm::vec3(m_gridSize * 0.45f, 0.05f, m_gridSize * 0.45f), color);
        }
    }

    // Draw selected object bounds
    if (m_selectedObjectIndex >= 0) {
        debugDraw.AddAABB(m_selectedObjectPosition, glm::vec3(0.5f), glm::vec4(1.0f, 1.0f, 0.0f, 1.0f));
    }
}

void StandaloneEditor::ProcessInput() {
    // Input processing will be handled in Update for now
}

void StandaloneEditor::SetEditMode(EditMode mode) {
    m_editMode = mode;
    spdlog::info("Editor mode changed to: {}", static_cast<int>(mode));
}

void StandaloneEditor::NewMap(int width, int height) {
    spdlog::info("Creating new map: {}x{}", width, height);

    m_mapWidth = width;
    m_mapHeight = height;

    // Initialize terrain data
    int numTiles = width * height;
    m_terrainTiles.resize(numTiles, 0);  // 0 = grass
    m_terrainHeights.resize(numTiles, 0.0f);  // Flat terrain

    m_currentMapPath.clear();
    spdlog::info("New map created");
}

bool StandaloneEditor::LoadMap(const std::string& path) {
    spdlog::info("Loading map from: {}", path);
    // TODO: Implement map loading
    spdlog::warn("Map loading not yet implemented");
    return false;
}

bool StandaloneEditor::SaveMap(const std::string& path) {
    spdlog::info("Saving map to: {}", path);
    // TODO: Implement map saving
    spdlog::warn("Map saving not yet implemented");
    return false;
}

// UI Rendering Functions

void StandaloneEditor::RenderAssetBrowser() {
    ImGui::Begin("Asset Browser", &m_showAssetBrowser);

    ImGui::Text("Assets Directory: %s", m_assetDirectory.c_str());
    ImGui::Separator();

    // Simple folder tree
    if (ImGui::TreeNode("Textures")) {
        ImGui::Selectable("grass.png");
        ImGui::Selectable("dirt.png");
        ImGui::Selectable("stone.png");
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Models")) {
        ImGui::Selectable("tree.fbx");
        ImGui::Selectable("rock.fbx");
        ImGui::Selectable("building.fbx");
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Materials")) {
        ImGui::Selectable("grass_material.mat");
        ImGui::Selectable("stone_material.mat");
        ImGui::TreePop();
    }

    ImGui::End();
}

void StandaloneEditor::RenderTerrainPanel() {
    ImGui::Begin("Terrain Editor", &m_showTerrainPanel);

    ImGui::Text("Terrain Tools");
    ImGui::Separator();

    ImGui::Text("Brush Type:");
    if (ImGui::RadioButton("Grass", m_selectedBrush == TerrainBrush::Grass)) m_selectedBrush = TerrainBrush::Grass;
    if (ImGui::RadioButton("Dirt", m_selectedBrush == TerrainBrush::Dirt)) m_selectedBrush = TerrainBrush::Dirt;
    if (ImGui::RadioButton("Stone", m_selectedBrush == TerrainBrush::Stone)) m_selectedBrush = TerrainBrush::Stone;
    if (ImGui::RadioButton("Sand", m_selectedBrush == TerrainBrush::Sand)) m_selectedBrush = TerrainBrush::Sand;
    if (ImGui::RadioButton("Water", m_selectedBrush == TerrainBrush::Water)) m_selectedBrush = TerrainBrush::Water;

    ImGui::Separator();
    ImGui::Text("Sculpting:");
    if (ImGui::RadioButton("Raise", m_selectedBrush == TerrainBrush::Raise)) m_selectedBrush = TerrainBrush::Raise;
    if (ImGui::RadioButton("Lower", m_selectedBrush == TerrainBrush::Lower)) m_selectedBrush = TerrainBrush::Lower;

    ImGui::Separator();
    ImGui::SliderInt("Brush Size", &m_brushSize, 1, 10);
    ImGui::SliderFloat("Strength", &m_brushStrength, 0.1f, 2.0f);

    ImGui::End();
}

void StandaloneEditor::RenderObjectPanel() {
    ImGui::Begin("Object Placement", &m_showObjectPanel);

    ImGui::Text("Place Objects");
    ImGui::Separator();

    if (ImGui::TreeNode("Nature")) {
        if (ImGui::Selectable("Tree")) {}
        if (ImGui::Selectable("Rock")) {}
        if (ImGui::Selectable("Bush")) {}
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Buildings")) {
        if (ImGui::Selectable("House")) {}
        if (ImGui::Selectable("Tower")) {}
        if (ImGui::Selectable("Wall")) {}
        ImGui::TreePop();
    }

    if (ImGui::TreeNode("Units")) {
        if (ImGui::Selectable("Worker")) {}
        if (ImGui::Selectable("Soldier")) {}
        ImGui::TreePop();
    }

    ImGui::End();
}

void StandaloneEditor::RenderMaterialPanel() {
    ImGui::Begin("Material Editor", &m_showMaterialPanel);

    ImGui::Text("Material Properties");
    ImGui::Separator();

    ImGui::Text("(Material editor UI goes here)");

    ImGui::End();
}

void StandaloneEditor::RenderPropertiesPanel() {
    ImGui::Begin("Properties", &m_showPropertiesPanel);

    if (m_selectedObjectIndex >= 0) {
        ImGui::Text("Selected Object");
        ImGui::Separator();

        ImGui::DragFloat3("Position", &m_selectedObjectPosition.x, 0.1f);
        ImGui::DragFloat3("Rotation", &m_selectedObjectRotation.x, 1.0f);
        ImGui::DragFloat3("Scale", &m_selectedObjectScale.x, 0.1f);
    } else {
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "No object selected");
    }

    ImGui::End();
}

void StandaloneEditor::RenderToolsPanel() {
    ImGui::Begin("Tools", &m_showPropertiesPanel);

    ImGui::Text("Edit Tools");
    ImGui::Separator();

    if (ImGui::Button("Select\n[Q]", ImVec2(90, 50))) {
        SetEditMode(EditMode::ObjectSelect);
    }
    ImGui::SameLine();
    if (ImGui::Button("Move\n[W]", ImVec2(90, 50))) {
        // Set move tool
    }

    if (ImGui::Button("Rotate\n[E]", ImVec2(90, 50))) {
        // Set rotate tool
    }
    ImGui::SameLine();
    if (ImGui::Button("Scale\n[R]", ImVec2(90, 50))) {
        // Set scale tool
    }

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Text("Terrain Tools");
    ImGui::Separator();

    if (ImGui::Button("Paint\n[1]", ImVec2(90, 50))) {
        SetEditMode(EditMode::TerrainPaint);
    }
    ImGui::SameLine();
    if (ImGui::Button("Sculpt\n[2]", ImVec2(90, 50))) {
        SetEditMode(EditMode::TerrainSculpt);
    }

    if (ImGui::Button("Smooth\n[3]", ImVec2(90, 50))) {
        // Set smooth tool
    }
    ImGui::SameLine();
    if (ImGui::Button("Flatten\n[4]", ImVec2(90, 50))) {
        // Set flatten tool
    }

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Text("Placement Tools");
    ImGui::Separator();

    if (ImGui::Button("Place Object\n[5]", ImVec2(90, 50))) {
        SetEditMode(EditMode::ObjectPlace);
    }
    ImGui::SameLine();
    if (ImGui::Button("Paint Foliage\n[6]", ImVec2(90, 50))) {
        // Set foliage paint tool
    }

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Text("Brush Settings");
    ImGui::Separator();

    ImGui::SliderInt("Size", &m_brushSize, 1, 20);
    ImGui::SliderFloat("Strength", &m_brushStrength, 0.1f, 5.0f);
    ImGui::Checkbox("Snap to Grid", &m_snapToGrid);

    ImGui::End();
}

void StandaloneEditor::RenderContentBrowser() {
    ImGui::Begin("Content Browser");

    ImGui::BeginChild("ContentToolbar", ImVec2(0, 30), true);
    if (ImGui::Button("Import")) {}
    ImGui::SameLine();
    if (ImGui::Button("New Folder")) {}
    ImGui::SameLine();
    ImGui::Text("Path: /Assets/");
    ImGui::EndChild();

    ImGui::BeginChild("ContentArea", ImVec2(0, 0), true);

    // Folder/File tree on left
    ImGui::BeginChild("Folders", ImVec2(200, 0), true);
    ImGui::Text("Folders");
    ImGui::Separator();

    if (ImGui::TreeNode("Assets")) {
        if (ImGui::TreeNode("Textures")) {
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Materials")) {
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Models")) {
            if (ImGui::TreeNode("Trees")) {
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Rocks")) {
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Buildings")) {
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Sounds")) {
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Scripts")) {
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    ImGui::EndChild();

    ImGui::SameLine();

    // Content grid on right
    ImGui::BeginChild("ContentGrid", ImVec2(0, 0), true);

    ImGui::Text("Content");
    ImGui::Separator();

    // Display items as grid of thumbnails
    float thumbnailSize = 64.0f;
    float cellSize = thumbnailSize + 10.0f;
    int columns = (int)((ImGui::GetContentRegionAvail().x) / cellSize);
    if (columns < 1) columns = 1;

    const char* items[] = {
        "tree_oak.fbx", "tree_pine.fbx", "rock_01.fbx", "rock_02.fbx",
        "grass_texture.png", "dirt_texture.png", "building_01.fbx", "wall_01.fbx"
    };

    for (int i = 0; i < 8; i++) {
        ImGui::BeginGroup();
        ImGui::Button("##thumb", ImVec2(thumbnailSize, thumbnailSize));
        if (ImGui::IsItemHovered() && ImGui::IsMouseDoubleClicked(0)) {
            spdlog::info("Double-clicked: {}", items[i]);
        }
        ImGui::Text("%s", items[i]);
        ImGui::EndGroup();

        if ((i + 1) % columns != 0) ImGui::SameLine();
    }

    ImGui::EndChild();

    ImGui::EndChild();
    ImGui::End();
}

void StandaloneEditor::RenderDetailsPanel() {
    ImGui::Begin("Details");

    if (m_selectedObjectIndex >= 0) {
        ImGui::Text("Selected Object Properties");
        ImGui::Separator();

        ImGui::Text("Transform");
        if (ImGui::CollapsingHeader("Transform", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::DragFloat3("Location", &m_selectedObjectPosition.x, 0.1f);
            ImGui::DragFloat3("Rotation", &m_selectedObjectRotation.x, 1.0f);
            ImGui::DragFloat3("Scale", &m_selectedObjectScale.x, 0.01f);
        }

        if (ImGui::CollapsingHeader("Rendering")) {
            static bool castShadows = true;
            static bool receiveShadows = true;
            static int renderLayer = 0;

            ImGui::Checkbox("Cast Shadows", &castShadows);
            ImGui::Checkbox("Receive Shadows", &receiveShadows);
            ImGui::SliderInt("Render Layer", &renderLayer, 0, 31);
        }

        if (ImGui::CollapsingHeader("Physics")) {
            static bool enablePhysics = false;
            static float mass = 1.0f;

            ImGui::Checkbox("Enable Physics", &enablePhysics);
            if (enablePhysics) {
                ImGui::DragFloat("Mass", &mass, 0.1f, 0.1f, 1000.0f);
            }
        }

        if (ImGui::CollapsingHeader("Tags & Layers")) {
            static char tag[64] = "Default";
            ImGui::InputText("Tag", tag, 64);
        }
    } else {
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "No object selected");
        ImGui::Separator();

        ImGui::Text("Scene Settings");
        if (ImGui::CollapsingHeader("Environment", ImGuiTreeNodeFlags_DefaultOpen)) {
            static float ambientIntensity = 0.2f;
            static float skyboxRotation = 0.0f;

            ImGui::SliderFloat("Ambient Intensity", &ambientIntensity, 0.0f, 1.0f);
            ImGui::SliderFloat("Skybox Rotation", &skyboxRotation, 0.0f, 360.0f);
        }

        if (ImGui::CollapsingHeader("Lighting")) {
            static glm::vec3 sunDirection(-0.5f, -1.0f, -0.5f);
            static glm::vec3 sunColor(1.0f, 0.95f, 0.9f);

            ImGui::DragFloat3("Sun Direction", &sunDirection.x, 0.01f, -1.0f, 1.0f);
            ImGui::ColorEdit3("Sun Color", &sunColor.x);
        }
    }

    ImGui::End();
}

void StandaloneEditor::RenderViewportControls() {
    // Viewport controls as overlay within viewport window
    ImGui::SetNextWindowBgAlpha(0.7f);
    ImVec2 windowPos = ImGui::GetWindowPos();
    ImVec2 windowSize = ImGui::GetWindowSize();

    ImGui::SetCursorPos(ImVec2(windowSize.x - 220, 10));
    ImGui::BeginChild("ViewportControls", ImVec2(210, 0), ImGuiChildFlags_Border);

    ImGui::Text("Viewport");
    ImGui::Separator();

    // Projection mode
    static int projectionMode = 0;
    ImGui::Text("Projection:");
    ImGui::RadioButton("Perspective", &projectionMode, 0); ImGui::SameLine();
    ImGui::RadioButton("Orthographic", &projectionMode, 1);

    ImGui::Separator();

    // View mode
    static int viewMode = 0;
    ImGui::Text("View:");
    if (ImGui::Button("Free")) viewMode = 0;
    ImGui::SameLine();
    if (ImGui::Button("Top (Z)")) viewMode = 1;
    if (ImGui::Button("Front (Y)")) viewMode = 2;
    ImGui::SameLine();
    if (ImGui::Button("Right (X)")) viewMode = 3;

    ImGui::Separator();

    // Render mode
    static int renderMode = 0;
    ImGui::Text("Shading:");
    ImGui::RadioButton("Lit", &renderMode, 0);
    ImGui::RadioButton("Unlit", &renderMode, 1);
    ImGui::RadioButton("Wireframe", &renderMode, 2);

    ImGui::Separator();

    // Viewport options
    ImGui::Checkbox("Grid", &m_showGrid);
    ImGui::Checkbox("Gizmos", &m_showGizmos);

    ImGui::EndChild();
}

void StandaloneEditor::RenderStatusBar() {
    auto& window = Nova::Engine::Instance().GetWindow();
    ImVec2 windowSize(static_cast<float>(window.GetWidth()), 25.0f);

    ImGui::SetNextWindowPos(ImVec2(0, window.GetHeight() - 25.0f));
    ImGui::SetNextWindowSize(windowSize);

    ImGui::Begin("StatusBar", nullptr,
        ImGuiWindowFlags_NoTitleBar | ImGuiWindowFlags_NoResize |
        ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoScrollbar);

    ImGui::Text("Map: %dx%d | Mode: %s | Camera: (%.1f, %.1f, %.1f)",
        m_mapWidth, m_mapHeight,
        m_editMode == EditMode::TerrainPaint ? "Paint" :
        m_editMode == EditMode::TerrainSculpt ? "Sculpt" :
        m_editMode == EditMode::ObjectPlace ? "Place" :
        m_editMode == EditMode::ObjectSelect ? "Select" : "None",
        m_editorCameraPos.x, m_editorCameraPos.y, m_editorCameraPos.z);

    ImGui::End();
}

// Dialog Functions

void StandaloneEditor::ShowNewMapDialog() {
    ImGui::OpenPopup("New Map");

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    if (ImGui::BeginPopupModal("New Map", &m_showNewMapDialog, ImGuiWindowFlags_AlwaysAutoResize)) {
        static int width = 64;
        static int height = 64;

        ImGui::InputInt("Width", &width);
        ImGui::InputInt("Height", &height);

        ImGui::Separator();

        if (ImGui::Button("Create", ImVec2(120, 0))) {
            NewMap(width, height);
            m_showNewMapDialog = false;
        }
        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            m_showNewMapDialog = false;
        }

        ImGui::EndPopup();
    }
}

void StandaloneEditor::ShowLoadMapDialog() {
    ImGui::OpenPopup("Load Map");

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    if (ImGui::BeginPopupModal("Load Map", &m_showLoadMapDialog, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("Select a map file to load:");
        ImGui::Separator();

        // Simple file list
        for (const auto& file : m_recentFiles) {
            if (ImGui::Selectable(file.c_str())) {
                LoadMap(file);
                m_showLoadMapDialog = false;
            }
        }

        ImGui::Separator();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            m_showLoadMapDialog = false;
        }

        ImGui::EndPopup();
    }
}

void StandaloneEditor::ShowSaveMapDialog() {
    ImGui::OpenPopup("Save Map");

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    if (ImGui::BeginPopupModal("Save Map", &m_showSaveMapDialog, ImGuiWindowFlags_AlwaysAutoResize)) {
        static char filename[256] = "untitled.map";

        ImGui::InputText("Filename", filename, sizeof(filename));

        ImGui::Separator();

        if (ImGui::Button("Save", ImVec2(120, 0))) {
            SaveMap(filename);
            m_showSaveMapDialog = false;
        }
        ImGui::SameLine();
        if (ImGui::Button("Cancel", ImVec2(120, 0))) {
            m_showSaveMapDialog = false;
        }

        ImGui::EndPopup();
    }
}

void StandaloneEditor::ShowAboutDialog() {
    ImGui::OpenPopup("About Editor");

    ImVec2 center = ImGui::GetMainViewport()->GetCenter();
    ImGui::SetNextWindowPos(center, ImGuiCond_Appearing, ImVec2(0.5f, 0.5f));

    if (ImGui::BeginPopupModal("About Editor", &m_showAboutDialog, ImGuiWindowFlags_AlwaysAutoResize)) {
        ImGui::Text("Nova3D RTS Editor");
        ImGui::Text("Version 1.0");
        ImGui::Separator();
        ImGui::Text("A standalone level editor for creating");
        ImGui::Text("custom maps and scenarios.");
        ImGui::Separator();

        if (ImGui::Button("Close", ImVec2(120, 0))) {
            m_showAboutDialog = false;
        }

        ImGui::EndPopup();
    }
}

// Terrain editing functions (stubs for now)

void StandaloneEditor::PaintTerrain(int x, int y) {
    // TODO: Implement terrain painting
}

void StandaloneEditor::SculptTerrain(int x, int y, float strength) {
    // TODO: Implement terrain sculpting
}

// Object editing functions (stubs for now)

void StandaloneEditor::PlaceObject(const glm::vec3& position, const std::string& objectType) {
    // TODO: Implement object placement
}

void StandaloneEditor::SelectObject(const glm::vec3& rayOrigin, const glm::vec3& rayDir) {
    // TODO: Implement object selection
}

void StandaloneEditor::TransformSelectedObject() {
    // TODO: Implement object transformation
}

void StandaloneEditor::DeleteSelectedObject() {
    // TODO: Implement object deletion
}

// ========================================
// Docking System Implementation
// ========================================

const char* StandaloneEditor::GetPanelName(PanelID panel) {
    switch (panel) {
        case PanelID::Viewport: return "Viewport";
        case PanelID::Tools: return "Tools";
        case PanelID::ContentBrowser: return "Content Browser";
        case PanelID::Details: return "Details";
        case PanelID::MaterialEditor: return "Material Editor";
        case PanelID::EngineStats: return "Engine Stats";
        default: return "Unknown";
    }
}

StandaloneEditor::DockZone StandaloneEditor::GetDropZone(ImVec2 mousePos, ImVec2 windowPos, ImVec2 windowSize) {
    // Calculate relative mouse position
    ImVec2 relPos(mousePos.x - windowPos.x, mousePos.y - windowPos.y);

    // Check if mouse is within window bounds
    if (relPos.x < 0 || relPos.y < 0 || relPos.x > windowSize.x || relPos.y > windowSize.y) {
        return DockZone::None;
    }

    float normalizedX = relPos.x / windowSize.x;
    float normalizedY = relPos.y / windowSize.y;

    // Priority order: Top > Bottom > Left > Right > Center

    // Top zone (excluding left/right corners)
    if (normalizedY < m_dropZoneMargin && normalizedX > m_dropZoneMargin && normalizedX < (1.0f - m_dropZoneMargin)) {
        return DockZone::Top;
    }

    // Bottom zone (excluding left/right corners)
    if (normalizedY > (1.0f - m_dropZoneMargin) && normalizedX > m_dropZoneMargin && normalizedX < (1.0f - m_dropZoneMargin)) {
        return DockZone::Bottom;
    }

    // Left zone
    if (normalizedX < m_dropZoneMargin) {
        return DockZone::Left;
    }

    // Right zone
    if (normalizedX > (1.0f - m_dropZoneMargin)) {
        return DockZone::Right;
    }

    // Center (default)
    return DockZone::Center;
}

void StandaloneEditor::DrawDropIndicator(DockZone zone, ImVec2 pos, ImVec2 size) {
    if (zone == DockZone::None || zone == DockZone::Floating) {
        return;
    }

    ImDrawList* drawList = ImGui::GetForegroundDrawList();
    ImVec2 dropPos = pos;
    ImVec2 dropSize = size;

    // Calculate drop zone rectangle based on zone type
    switch (zone) {
        case DockZone::Left:
            dropSize.x = m_leftZoneWidth;
            break;
        case DockZone::Right:
            dropPos.x = pos.x + size.x - m_rightZoneWidth;
            dropSize.x = m_rightZoneWidth;
            break;
        case DockZone::Top:
            dropSize.y = m_topZoneHeight;
            break;
        case DockZone::Bottom:
            dropPos.y = pos.y + size.y - m_bottomZoneHeight;
            dropSize.y = m_bottomZoneHeight;
            break;
        case DockZone::Center:
            // Adjust for docked panels
            dropPos.x += m_leftZoneWidth;
            dropPos.y += m_topZoneHeight;
            dropSize.x -= (m_leftZoneWidth + m_rightZoneWidth);
            dropSize.y -= (m_topZoneHeight + m_bottomZoneHeight);
            break;
        default:
            break;
    }

    // Draw semi-transparent overlay with gold border
    ImU32 fillColor = IM_COL32(100, 80, 30, 100);   // Gold tint
    ImU32 borderColor = IM_COL32(200, 160, 60, 200); // Bright gold

    drawList->AddRectFilled(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), fillColor);
    drawList->AddRect(dropPos, ImVec2(dropPos.x + dropSize.x, dropPos.y + dropSize.y), borderColor, 0.0f, 0, 3.0f);
}

void StandaloneEditor::RenderDockingLayout() {
    auto& window = Nova::Engine::Instance().GetWindow();
    ImVec2 viewportPos = ImGui::GetMainViewport()->WorkPos;
    ImVec2 viewportSize = ImGui::GetMainViewport()->WorkSize;

    // Account for menu bar
    float menuBarHeight = ImGui::GetFrameHeight();
    viewportPos.y += menuBarHeight;
    viewportSize.y -= menuBarHeight;

    // Calculate zone boundaries
    ImVec2 leftPos = viewportPos;
    ImVec2 leftSize(m_leftZoneWidth, viewportSize.y - m_bottomZoneHeight);

    ImVec2 rightPos(viewportPos.x + viewportSize.x - m_rightZoneWidth, viewportPos.y);
    ImVec2 rightSize(m_rightZoneWidth, viewportSize.y - m_bottomZoneHeight);

    ImVec2 topPos(viewportPos.x + m_leftZoneWidth, viewportPos.y);
    ImVec2 topSize(viewportSize.x - m_leftZoneWidth - m_rightZoneWidth, m_topZoneHeight);

    ImVec2 bottomPos(viewportPos.x, viewportPos.y + viewportSize.y - m_bottomZoneHeight);
    ImVec2 bottomSize(viewportSize.x, m_bottomZoneHeight);

    ImVec2 centerPos(viewportPos.x + m_leftZoneWidth, viewportPos.y + m_topZoneHeight);
    ImVec2 centerSize(
        viewportSize.x - m_leftZoneWidth - m_rightZoneWidth,
        viewportSize.y - m_topZoneHeight - m_bottomZoneHeight
    );

    // Render panels in their zones
    for (const auto& layout : m_panelLayouts) {
        if (!layout.isVisible) continue;

        switch (layout.zone) {
            case DockZone::Left:
                RenderPanel(layout.id, leftPos, leftSize);
                break;
            case DockZone::Right:
                RenderPanel(layout.id, rightPos, rightSize);
                break;
            case DockZone::Top:
                RenderPanel(layout.id, topPos, topSize);
                break;
            case DockZone::Bottom:
                RenderPanel(layout.id, bottomPos, bottomSize);
                break;
            case DockZone::Center:
                RenderPanel(layout.id, centerPos, centerSize);
                break;
            case DockZone::Floating:
                // Render as regular window (no fixed position/size)
                ImGui::Begin(GetPanelName(layout.id));
                RenderPanelContent(layout.id);
                ImGui::End();
                break;
            default:
                break;
        }
    }

    // Draw drop indicators when dragging
    if (m_isDraggingPanel && m_hoveredZone != DockZone::None) {
        DrawDropIndicator(m_hoveredZone, viewportPos, viewportSize);
    }
}

void StandaloneEditor::RenderPanel(PanelID panel, ImVec2 pos, ImVec2 size) {
    ImGui::SetNextWindowPos(pos);
    ImGui::SetNextWindowSize(size);

    ImGuiWindowFlags flags = ImGuiWindowFlags_NoMove | ImGuiWindowFlags_NoResize |
                             ImGuiWindowFlags_NoCollapse | ImGuiWindowFlags_NoBringToFrontOnFocus;

    // Allow dragging from title bar to undock
    if (ImGui::Begin(GetPanelName(panel), nullptr, flags)) {
        // Check if window is being dragged
        if (ImGui::IsWindowHovered() && ImGui::IsMouseDragging(ImGuiMouseButton_Left)) {
            ImVec2 mousePos = ImGui::GetMousePos();
            ImVec2 windowPos = ImGui::GetWindowPos();

            // Only start dragging if dragging from title bar
            if (mousePos.y < windowPos.y + ImGui::GetTextLineHeightWithSpacing() + 10) {
                m_isDraggingPanel = true;
                m_draggedPanel = panel;

                // Get drop zone under mouse
                auto& window = Nova::Engine::Instance().GetWindow();
                ImVec2 viewportPos = ImGui::GetMainViewport()->WorkPos;
                ImVec2 viewportSize = ImGui::GetMainViewport()->WorkSize;
                m_hoveredZone = GetDropZone(mousePos, viewportPos, viewportSize);
            }
        }

        // Stop dragging on mouse release
        if (m_isDraggingPanel && !ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
            // Update panel zone if dropped in valid zone
            if (m_hoveredZone != DockZone::None) {
                for (auto& layout : m_panelLayouts) {
                    if (layout.id == m_draggedPanel) {
                        layout.zone = m_hoveredZone;
                        break;
                    }
                }
            }
            m_isDraggingPanel = false;
            m_hoveredZone = DockZone::None;
        }

        RenderPanelContent(panel);
    }
    ImGui::End();
}

void StandaloneEditor::RenderPanelContent(PanelID panel) {
    switch (panel) {
        case PanelID::Viewport:
            RenderViewportControls();
            break;
        case PanelID::Tools:
            RenderUnifiedToolsPanel();
            break;
        case PanelID::ContentBrowser:
            RenderUnifiedContentBrowser();
            break;
        case PanelID::Details:
            RenderDetailsContent();
            break;
        case PanelID::MaterialEditor:
            RenderMaterialEditorContent();
            break;
        case PanelID::EngineStats:
            RenderEngineStatsContent();
            break;
    }
}

void StandaloneEditor::RenderUnifiedToolsPanel() {
    // Merged Tools + Terrain Editor

    if (ImGui::CollapsingHeader("Edit Tools", ImGuiTreeNodeFlags_DefaultOpen)) {
        float buttonWidth = (ImGui::GetContentRegionAvail().x - ImGui::GetStyle().ItemSpacing.x) * 0.5f - 2;

        if (ImGui::Button("Select [Q]", ImVec2(buttonWidth, 40))) {
            SetEditMode(EditMode::ObjectSelect);
        }
        ImGui::SameLine();
        if (ImGui::Button("Move [W]", ImVec2(buttonWidth, 40))) {
            // Set move tool
        }

        if (ImGui::Button("Rotate [E]", ImVec2(buttonWidth, 40))) {
            // Set rotate tool
        }
        ImGui::SameLine();
        if (ImGui::Button("Scale [R]", ImVec2(buttonWidth, 40))) {
            // Set scale tool
        }
    }

    if (ImGui::CollapsingHeader("Terrain Tools", ImGuiTreeNodeFlags_DefaultOpen)) {
        float buttonWidth = (ImGui::GetContentRegionAvail().x - ImGui::GetStyle().ItemSpacing.x) * 0.5f - 2;

        if (ImGui::Button("Paint [1]", ImVec2(buttonWidth, 40))) {
            SetEditMode(EditMode::TerrainPaint);
        }
        ImGui::SameLine();
        if (ImGui::Button("Sculpt [2]", ImVec2(buttonWidth, 40))) {
            SetEditMode(EditMode::TerrainSculpt);
        }

        if (ImGui::Button("Smooth [3]", ImVec2(buttonWidth, 40))) {
            // Set smooth tool
        }
        ImGui::SameLine();
        if (ImGui::Button("Flatten [4]", ImVec2(buttonWidth, 40))) {
            // Set flatten tool
        }

        ImGui::Spacing();
        ImGui::Separator();

        ImGui::Text("Brush Type:");
        if (ImGui::RadioButton("Grass", m_selectedBrush == TerrainBrush::Grass)) m_selectedBrush = TerrainBrush::Grass;
        if (ImGui::RadioButton("Dirt", m_selectedBrush == TerrainBrush::Dirt)) m_selectedBrush = TerrainBrush::Dirt;
        if (ImGui::RadioButton("Stone", m_selectedBrush == TerrainBrush::Stone)) m_selectedBrush = TerrainBrush::Stone;
        if (ImGui::RadioButton("Sand", m_selectedBrush == TerrainBrush::Sand)) m_selectedBrush = TerrainBrush::Sand;
        if (ImGui::RadioButton("Water", m_selectedBrush == TerrainBrush::Water)) m_selectedBrush = TerrainBrush::Water;
    }

    if (ImGui::CollapsingHeader("Placement Tools")) {
        float buttonWidth = (ImGui::GetContentRegionAvail().x - ImGui::GetStyle().ItemSpacing.x) * 0.5f - 2;

        if (ImGui::Button("Place Object [5]", ImVec2(buttonWidth, 40))) {
            SetEditMode(EditMode::ObjectPlace);
        }
        ImGui::SameLine();
        if (ImGui::Button("Foliage [6]", ImVec2(buttonWidth, 40))) {
            // Set foliage paint tool
        }
    }

    if (ImGui::CollapsingHeader("Brush Settings", ImGuiTreeNodeFlags_DefaultOpen)) {
        ImGui::SliderInt("Size", &m_brushSize, 1, 20);
        ImGui::SliderFloat("Strength", &m_brushStrength, 0.1f, 5.0f);
        ImGui::Checkbox("Snap to Grid", &m_snapToGrid);
    }
}

void StandaloneEditor::RenderUnifiedContentBrowser() {
    // Merged Asset Browser + Object Placement + Content Browser

    ImGui::BeginChild("ContentToolbar", ImVec2(0, 30), true);
    if (ImGui::Button("Import")) {}
    ImGui::SameLine();
    if (ImGui::Button("New Folder")) {}
    ImGui::SameLine();
    ImGui::Text("Path: /Assets/");
    ImGui::EndChild();

    ImGui::BeginChild("ContentArea", ImVec2(0, 0), false);

    // Left side: Folder tree with categories
    ImGui::BeginChild("Folders", ImVec2(200, 0), true);
    ImGui::Text("Folders");
    ImGui::Separator();

    if (ImGui::TreeNodeEx("Assets", ImGuiTreeNodeFlags_DefaultOpen)) {
        if (ImGui::TreeNode("Textures")) {
            if (ImGui::Selectable("grass.png")) {}
            if (ImGui::Selectable("dirt.png")) {}
            if (ImGui::Selectable("stone.png")) {}
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Materials")) {
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Models")) {
            if (ImGui::TreeNode("Trees")) {
                if (ImGui::Selectable("tree_oak.fbx")) {}
                if (ImGui::Selectable("tree_pine.fbx")) {}
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Rocks")) {
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Buildings")) {
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Prefabs")) {
            if (ImGui::TreeNodeEx("Nature", ImGuiTreeNodeFlags_DefaultOpen)) {
                if (ImGui::Selectable("Tree")) {}
                if (ImGui::Selectable("Rock")) {}
                if (ImGui::Selectable("Bush")) {}
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Buildings")) {
                if (ImGui::Selectable("House")) {}
                if (ImGui::Selectable("Tower")) {}
                if (ImGui::Selectable("Wall")) {}
                ImGui::TreePop();
            }
            if (ImGui::TreeNode("Units")) {
                if (ImGui::Selectable("Worker")) {}
                if (ImGui::Selectable("Soldier")) {}
                ImGui::TreePop();
            }
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Sounds")) {
            ImGui::TreePop();
        }
        if (ImGui::TreeNode("Scripts")) {
            ImGui::TreePop();
        }
        ImGui::TreePop();
    }

    ImGui::EndChild();

    ImGui::SameLine();

    // Right side: Content grid
    ImGui::BeginChild("ContentGrid", ImVec2(0, 0), true);

    ImGui::Text("Content");
    ImGui::Separator();

    // Display items as grid of thumbnails
    float thumbnailSize = 64.0f;
    float cellSize = thumbnailSize + 10.0f;
    int columns = (int)((ImGui::GetContentRegionAvail().x) / cellSize);
    if (columns < 1) columns = 1;

    const char* items[] = {
        "tree_oak.fbx", "tree_pine.fbx", "rock_01.fbx", "rock_02.fbx",
        "grass_tex.png", "dirt_tex.png", "building_01.fbx", "wall_01.fbx"
    };

    for (int i = 0; i < 8; i++) {
        ImGui::PushID(i);
        if (ImGui::Button(items[i], ImVec2(thumbnailSize, thumbnailSize))) {
            // Select item
        }
        ImGui::PopID();

        if ((i + 1) % columns != 0) {
            ImGui::SameLine();
        }
    }

    ImGui::EndChild();
    ImGui::EndChild();
}

void StandaloneEditor::RenderDetailsContent() {
    if (m_selectedObjectIndex >= 0) {
        ImGui::Text("Selected Object");
        ImGui::Separator();

        if (ImGui::CollapsingHeader("Transform", ImGuiTreeNodeFlags_DefaultOpen)) {
            ImGui::DragFloat3("Position", &m_selectedObjectPosition.x, 0.1f);
            ImGui::DragFloat3("Rotation", &m_selectedObjectRotation.x, 1.0f);
            ImGui::DragFloat3("Scale", &m_selectedObjectScale.x, 0.01f);
        }

        if (ImGui::CollapsingHeader("Rendering")) {
            static bool castShadows = true;
            static bool receiveShadows = true;
            ImGui::Checkbox("Cast Shadows", &castShadows);
            ImGui::Checkbox("Receive Shadows", &receiveShadows);
        }

        if (ImGui::CollapsingHeader("Physics")) {
            static bool enablePhysics = false;
            static float mass = 1.0f;
            ImGui::Checkbox("Enable Physics", &enablePhysics);
            if (enablePhysics) {
                ImGui::DragFloat("Mass", &mass, 0.1f);
            }
        }
    } else {
        ImGui::TextColored(ImVec4(0.7f, 0.7f, 0.7f, 1.0f), "No object selected");
        ImGui::Separator();

        if (ImGui::CollapsingHeader("Scene Settings", ImGuiTreeNodeFlags_DefaultOpen)) {
            static float ambientIntensity = 0.2f;
            ImGui::SliderFloat("Ambient", &ambientIntensity, 0.0f, 1.0f);
        }

        if (ImGui::CollapsingHeader("Lighting")) {
            static float sunDirection[3] = {-0.5f, -1.0f, -0.5f};
            ImGui::DragFloat3("Sun Dir", sunDirection, 0.01f, -1.0f, 1.0f);
        }
    }
}

void StandaloneEditor::RenderMaterialEditorContent() {
    ImGui::Text("Material Editor");
    ImGui::Separator();
    ImGui::TextWrapped("Material editor UI goes here...");
}

void StandaloneEditor::RenderEngineStatsContent() {
    ImGui::Text("Engine Statistics");
    ImGui::Separator();
    ImGui::Text("FPS: %.1f", ImGui::GetIO().Framerate);
    ImGui::Text("Frame: %.3f ms", 1000.0f / ImGui::GetIO().Framerate);
}
