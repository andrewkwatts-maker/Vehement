#version 460 core

// Temporal Reprojection for SDF Rendering
// Reuses previous frame data to reduce raymarching cost
// Features:
// - Motion vector-based reprojection
// - Disocclusion detection
// - Temporal accumulation with exponential decay
// - Variance clamping for stability
// - Sub-pixel jittering support

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// =============================================================================
// Output Images (Current Frame)
// =============================================================================

layout(rgba16f, binding = 0) writeonly uniform image2D u_outputColor;
layout(rgba16f, binding = 1) writeonly uniform image2D u_outputNormal;
layout(r32f, binding = 2) writeonly uniform image2D u_outputDepth;
layout(r8ui, binding = 3) writeonly uniform uimage2D u_reprojectMask;  // 1 = reprojected, 0 = needs trace

// =============================================================================
// Input Images (Current Frame - New Samples)
// =============================================================================

layout(rgba16f, binding = 4) readonly uniform image2D u_currentColor;
layout(rgba16f, binding = 5) readonly uniform image2D u_currentNormal;
layout(r32f, binding = 6) readonly uniform image2D u_currentDepth;

// =============================================================================
// Input Images (Previous Frame - History)
// =============================================================================

uniform sampler2D u_prevColor;
uniform sampler2D u_prevNormal;
uniform sampler2D u_prevDepth;
uniform sampler2D u_prevMomentum;  // xy = color variance, z = history length

// =============================================================================
// Motion Vectors
// =============================================================================

uniform sampler2D u_motionVectors;  // Optional: explicit motion vectors

// =============================================================================
// Camera Matrices
// =============================================================================

uniform mat4 u_currentViewProj;
uniform mat4 u_currentInvViewProj;
uniform mat4 u_prevViewProj;
uniform mat4 u_prevInvViewProj;

uniform vec3 u_currentCameraPos;
uniform vec3 u_prevCameraPos;

// =============================================================================
// Temporal Parameters
// =============================================================================

uniform float u_temporalBlendFactor;     // Default: 0.1 (90% history, 10% new)
uniform float u_disocclusionThreshold;   // Default: 0.1 (world units)
uniform float u_normalThreshold;         // Default: 0.95 (cosine)
uniform float u_depthThreshold;          // Default: 0.02 (relative)
uniform bool u_useVarianceClamping;
uniform bool u_enableJitter;
uniform int u_frameIndex;

// =============================================================================
// Helper Functions
// =============================================================================

// Reconstruct world position from depth
vec3 reconstructWorldPos(vec2 uv, float depth, mat4 invViewProj) {
    vec2 ndc = uv * 2.0 - 1.0;
    vec4 clipPos = vec4(ndc, depth * 2.0 - 1.0, 1.0);
    vec4 worldPos = invViewProj * clipPos;
    return worldPos.xyz / worldPos.w;
}

// Project world position to screen space
vec2 projectToScreen(vec3 worldPos, mat4 viewProj) {
    vec4 clipPos = viewProj * vec4(worldPos, 1.0);
    clipPos.xyz /= clipPos.w;
    return clipPos.xy * 0.5 + 0.5;
}

// Sample with catmull-rom filter for better quality
vec4 sampleCatmullRom(sampler2D tex, vec2 uv, vec2 texelSize) {
    vec2 position = uv / texelSize;
    vec2 centerPosition = floor(position - 0.5) + 0.5;
    vec2 f = position - centerPosition;
    vec2 f2 = f * f;
    vec2 f3 = f2 * f;

    vec2 w0 = -0.5 * f3 + f2 - 0.5 * f;
    vec2 w1 = 1.5 * f3 - 2.5 * f2 + 1.0;
    vec2 w2 = -1.5 * f3 + 2.0 * f2 + 0.5 * f;
    vec2 w3 = 0.5 * f3 - 0.5 * f2;

    vec2 w12 = w1 + w2;
    vec2 tc0 = (centerPosition - 1.0) * texelSize;
    vec2 tc3 = (centerPosition + 2.0) * texelSize;
    vec2 tc12 = (centerPosition + w2 / w12) * texelSize;

    vec4 s0 = texture(tex, vec2(tc12.x, tc0.y));
    vec4 s1 = texture(tex, vec2(tc0.x, tc12.y));
    vec4 s2 = texture(tex, vec2(tc12.x, tc12.y));
    vec4 s3 = texture(tex, vec2(tc3.x, tc12.y));
    vec4 s4 = texture(tex, vec2(tc12.x, tc3.y));

    float cw0 = (w12.x * w0.y);
    float cw1 = (w0.x * w12.y);
    float cw2 = (w12.x * w12.y);
    float cw3 = (w3.x * w12.y);
    float cw4 = (w12.x * w3.y);

    return (s0 * cw0 + s1 * cw1 + s2 * cw2 + s3 * cw3 + s4 * cw4) /
           (cw0 + cw1 + cw2 + cw3 + cw4);
}

// Neighborhood variance clamping
vec3 clipAABB(vec3 color, vec3 minColor, vec3 maxColor) {
    vec3 center = 0.5 * (minColor + maxColor);
    vec3 extents = 0.5 * (maxColor - minColor);

    vec3 offset = color - center;
    vec3 ts = abs(extents) / max(abs(offset), vec3(0.0001));
    float t = min(min(ts.x, ts.y), ts.z);

    if (t < 1.0) {
        return center + offset * t;
    }
    return color;
}

// Calculate neighborhood statistics (for variance clamping)
void calculateNeighborhoodStats(
    ivec2 pixelCoord,
    out vec3 neighborMin,
    out vec3 neighborMax,
    out vec3 neighborMean,
    out float neighborVariance
) {
    vec3 m1 = vec3(0.0);
    vec3 m2 = vec3(0.0);
    vec3 vmin = vec3(1000.0);
    vec3 vmax = vec3(-1000.0);

    // 3x3 neighborhood
    for (int y = -1; y <= 1; y++) {
        for (int x = -1; x <= 1; x++) {
            ivec2 offset = ivec2(x, y);
            vec3 color = imageLoad(u_currentColor, pixelCoord + offset).rgb;

            m1 += color;
            m2 += color * color;
            vmin = min(vmin, color);
            vmax = max(vmax, color);
        }
    }

    // Statistics
    m1 /= 9.0;
    m2 /= 9.0;

    neighborMin = vmin;
    neighborMax = vmax;
    neighborMean = m1;

    vec3 variance = m2 - m1 * m1;
    neighborVariance = (variance.r + variance.g + variance.b) / 3.0;
}

// =============================================================================
// Main Reprojection Logic
// =============================================================================

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 screenSize = imageSize(u_outputColor);

    if (any(greaterThanEqual(pixelCoord, screenSize))) {
        return;
    }

    vec2 uv = (vec2(pixelCoord) + 0.5) / vec2(screenSize);

    // Load current frame data
    vec4 currentColor = imageLoad(u_currentColor, pixelCoord);
    vec4 currentNormal = imageLoad(u_currentNormal, pixelCoord);
    float currentDepth = imageLoad(u_currentDepth, pixelCoord).r;

    // Check if current pixel is valid
    bool hasCurrentSample = currentDepth < 1000.0;

    if (!hasCurrentSample) {
        // No current sample, store black and request trace
        imageStore(u_outputColor, pixelCoord, vec4(0, 0, 0, 1));
        imageStore(u_outputNormal, pixelCoord, vec4(0.5, 0.5, 1.0, 1.0));
        imageStore(u_outputDepth, pixelCoord, vec4(1000.0, 0, 0, 0));
        imageStore(u_reprojectMask, pixelCoord, uvec4(0, 0, 0, 0));
        return;
    }

    // Reconstruct current world position
    vec3 worldPos = reconstructWorldPos(uv, currentDepth, u_currentInvViewProj);

    // Project to previous frame
    vec2 prevUV = projectToScreen(worldPos, u_prevViewProj);

    // Check if reprojection is valid (on screen)
    bool validReprojection = all(greaterThanEqual(prevUV, vec2(0.0))) &&
                             all(lessThanEqual(prevUV, vec2(1.0)));

    if (!validReprojection) {
        // Outside screen bounds, can't reproject
        imageStore(u_outputColor, pixelCoord, currentColor);
        imageStore(u_outputNormal, pixelCoord, currentNormal);
        imageStore(u_outputDepth, pixelCoord, vec4(currentDepth, 0, 0, 0));
        imageStore(u_reprojectMask, pixelCoord, uvec4(0, 0, 0, 0));
        return;
    }

    // Sample previous frame with high-quality filter
    vec2 texelSize = 1.0 / vec2(screenSize);
    vec4 prevColor = sampleCatmullRom(u_prevColor, prevUV, texelSize);
    vec4 prevNormal = texture(u_prevNormal, prevUV);
    float prevDepth = texture(u_prevDepth, prevUV).r;
    vec4 prevMomentum = texture(u_prevMomentum, prevUV);

    // Reconstruct previous world position
    vec3 prevWorldPos = reconstructWorldPos(prevUV, prevDepth, u_prevInvViewProj);

    // Disocclusion detection
    float reprojError = length(worldPos - prevWorldPos);
    bool disoccluded = reprojError > u_disocclusionThreshold;

    // Normal consistency check
    vec3 currentNormalWS = currentNormal.xyz * 2.0 - 1.0;
    vec3 prevNormalWS = prevNormal.xyz * 2.0 - 1.0;
    float normalSimilarity = dot(currentNormalWS, prevNormalWS);
    bool normalMismatch = normalSimilarity < u_normalThreshold;

    // Depth consistency check
    float depthDiff = abs(currentDepth - prevDepth) / max(currentDepth, 0.001);
    bool depthMismatch = depthDiff > u_depthThreshold;

    // Determine if reprojection is valid
    bool canReproject = !disoccluded && !normalMismatch && !depthMismatch;

    vec3 finalColor;
    float historyLength = prevMomentum.z;

    if (canReproject) {
        // Valid reprojection - blend with history

        if (u_useVarianceClamping) {
            // Variance clamping to reduce ghosting
            vec3 neighborMin, neighborMax, neighborMean;
            float neighborVariance;
            calculateNeighborhoodStats(pixelCoord, neighborMin, neighborMax,
                                      neighborMean, neighborVariance);

            // Clamp history to current neighborhood
            vec3 clampedHistory = clipAABB(prevColor.rgb, neighborMin, neighborMax);

            // Adaptive blend factor based on variance
            float adaptiveBlend = mix(u_temporalBlendFactor, 0.3,
                                     clamp(neighborVariance * 10.0, 0.0, 1.0));

            finalColor = mix(clampedHistory, currentColor.rgb, adaptiveBlend);
        } else {
            // Simple exponential moving average
            finalColor = mix(prevColor.rgb, currentColor.rgb, u_temporalBlendFactor);
        }

        // Increment history length (saturate at 255)
        historyLength = min(historyLength + 1.0, 255.0);

        // Mark as reprojected
        imageStore(u_reprojectMask, pixelCoord, uvec4(1, 0, 0, 0));
    } else {
        // Disocclusion or mismatch - use current sample only
        finalColor = currentColor.rgb;
        historyLength = 1.0;

        // Mark as needing trace
        imageStore(u_reprojectMask, pixelCoord, uvec4(0, 0, 0, 0));
    }

    // Calculate color variance for next frame
    vec3 colorDiff = finalColor - currentColor.rgb;
    vec2 colorVariance = colorDiff.rg * colorDiff.rg;

    // Store results
    imageStore(u_outputColor, pixelCoord, vec4(finalColor, 1.0));
    imageStore(u_outputNormal, pixelCoord, currentNormal);
    imageStore(u_outputDepth, pixelCoord, vec4(currentDepth, 0, 0, 0));

    // Note: Momentum/variance would be stored to a separate output in practice
}
