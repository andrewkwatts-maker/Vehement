<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blend State Visual Editor</title>
    <style>
        :root {
            --bg-primary: #1e1e2e;
            --bg-secondary: #2a2a3e;
            --bg-tertiary: #363650;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0b0;
            --accent-primary: #4488ff;
            --accent-secondary: #44ff88;
            --accent-warning: #ffaa44;
            --accent-danger: #ff4444;
            --border-color: #404060;
            --node-state: #4488ff;
            --node-entry: #44ff88;
            --node-any: #ff8844;
            --transition-color: #a0a0b0;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
        }

        .editor-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        /* Toolbar */
        .toolbar {
            height: 40px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 10px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 0 10px;
            border-right: 1px solid var(--border-color);
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }

        .toolbar-btn:hover {
            background: var(--accent-primary);
        }

        .toolbar-btn.active {
            background: var(--accent-primary);
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* State List */
        .state-list {
            width: 200px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
        }

        .list-header {
            padding: 10px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .list-content {
            flex: 1;
            overflow-y: auto;
            padding: 5px;
        }

        .state-item {
            display: flex;
            align-items: center;
            padding: 8px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            margin-bottom: 2px;
        }

        .state-item:hover {
            background: var(--bg-tertiary);
        }

        .state-item.selected {
            background: var(--accent-primary);
        }

        .state-indicator {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            margin-right: 8px;
        }

        .state-indicator.entry {
            background: var(--node-entry);
        }

        .state-indicator.state {
            background: var(--node-state);
        }

        .state-indicator.any {
            background: var(--node-any);
        }

        /* Graph Canvas */
        .graph-area {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #graphCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .graph-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* Properties Panel */
        .properties-panel {
            width: 280px;
            background: var(--bg-secondary);
            border-left: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel-section {
            padding: 10px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 10px;
        }

        .property-row {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .property-label {
            width: 80px;
            font-size: 11px;
            color: var(--text-secondary);
        }

        .property-input {
            flex: 1;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 5px 8px;
            border-radius: 3px;
            font-size: 11px;
        }

        .property-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        select.property-input {
            cursor: pointer;
        }

        /* Condition List */
        .condition-item {
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 8px;
            margin-bottom: 6px;
        }

        .condition-row {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .condition-param {
            flex: 1;
            background: var(--bg-primary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 4px 6px;
            border-radius: 3px;
            font-size: 11px;
        }

        .condition-remove {
            background: var(--accent-danger);
            border: none;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px;
        }

        /* Parameter List */
        .parameter-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            background: var(--bg-tertiary);
            border-radius: 4px;
            margin-bottom: 4px;
        }

        .parameter-type {
            font-size: 9px;
            padding: 2px 6px;
            border-radius: 2px;
            margin-right: 8px;
        }

        .parameter-type.float {
            background: var(--accent-primary);
        }

        .parameter-type.int {
            background: var(--accent-secondary);
        }

        .parameter-type.bool {
            background: var(--accent-warning);
        }

        .parameter-type.trigger {
            background: var(--accent-danger);
        }

        .parameter-value {
            margin-left: auto;
            font-family: monospace;
            font-size: 11px;
        }

        /* Mini Preview */
        .mini-preview {
            height: 120px;
            background: #1a1a2a;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 11px;
        }

        /* Blend Space */
        .blend-space-2d {
            width: 100%;
            aspect-ratio: 1;
            background: var(--bg-tertiary);
            border-radius: 4px;
            position: relative;
            margin-top: 10px;
        }

        .blend-point {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-primary);
            border: 2px solid white;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
        }

        .blend-point.current {
            background: var(--accent-danger);
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-primary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="editor-container">
        <!-- Toolbar -->
        <div class="toolbar">
            <div class="toolbar-group">
                <button class="toolbar-btn" id="addStateBtn">+ State</button>
                <button class="toolbar-btn" id="addTransitionBtn">+ Transition</button>
                <button class="toolbar-btn" id="addParamBtn">+ Parameter</button>
            </div>
            <div class="toolbar-group">
                <button class="toolbar-btn" id="autoLayoutBtn">Auto Layout</button>
                <button class="toolbar-btn" id="frameAllBtn">Frame All</button>
            </div>
            <div class="toolbar-group">
                <button class="toolbar-btn" id="testModeBtn">Test Mode</button>
            </div>
            <div class="toolbar-group">
                <span style="font-size:11px;color:var(--text-secondary);">Blend Type:</span>
                <select class="property-input" id="blendType" style="width:100px;">
                    <option>State Machine</option>
                    <option>Blend Tree 1D</option>
                    <option>Blend Tree 2D</option>
                    <option>Direct</option>
                </select>
            </div>
        </div>

        <div class="main-content">
            <!-- State List -->
            <div class="state-list">
                <div class="list-header">
                    <span>States</span>
                    <button class="toolbar-btn" style="padding:2px 6px;font-size:10px;">+</button>
                </div>
                <div class="list-content" id="stateList">
                    <!-- States populated by JavaScript -->
                </div>

                <div class="list-header" style="margin-top:auto;">
                    <span>Parameters</span>
                    <button class="toolbar-btn" style="padding:2px 6px;font-size:10px;">+</button>
                </div>
                <div class="list-content" id="parameterList">
                    <!-- Parameters populated by JavaScript -->
                </div>
            </div>

            <!-- Graph Canvas -->
            <div class="graph-area">
                <canvas id="graphCanvas"></canvas>
                <div class="graph-info">
                    LMB: Select/Move | RMB: Pan | Scroll: Zoom | Shift+LMB: Create Transition
                </div>
            </div>

            <!-- Properties Panel -->
            <div class="properties-panel">
                <!-- State Properties -->
                <div class="panel-section" id="stateProps">
                    <div class="section-title">State Properties</div>
                    <div class="property-row">
                        <span class="property-label">Name</span>
                        <input type="text" class="property-input" id="stateName" value="Idle">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Animation</span>
                        <select class="property-input" id="stateAnimation">
                            <option>idle.anim</option>
                            <option>walk.anim</option>
                            <option>run.anim</option>
                            <option>attack.anim</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <span class="property-label">Speed</span>
                        <input type="number" class="property-input" id="stateSpeed" value="1.0" step="0.1">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Loop</span>
                        <select class="property-input" id="stateLoop">
                            <option>Loop</option>
                            <option>Once</option>
                            <option>Ping Pong</option>
                        </select>
                    </div>

                    <div class="section-title" style="margin-top:15px;">Preview</div>
                    <div class="mini-preview">
                        Animation Preview
                    </div>
                </div>

                <!-- Transition Properties -->
                <div class="panel-section" id="transitionProps" style="display:none;">
                    <div class="section-title">Transition Properties</div>
                    <div class="property-row">
                        <span class="property-label">From</span>
                        <input type="text" class="property-input" value="Idle" readonly>
                    </div>
                    <div class="property-row">
                        <span class="property-label">To</span>
                        <input type="text" class="property-input" value="Walk" readonly>
                    </div>
                    <div class="property-row">
                        <span class="property-label">Duration</span>
                        <input type="number" class="property-input" id="transitionDuration" value="0.2" step="0.05">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Offset</span>
                        <input type="number" class="property-input" id="transitionOffset" value="0" step="0.05">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Has Exit Time</span>
                        <select class="property-input" id="hasExitTime">
                            <option>Yes</option>
                            <option selected>No</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <span class="property-label">Exit Time</span>
                        <input type="number" class="property-input" id="exitTime" value="0.9" step="0.1" disabled>
                    </div>

                    <div class="section-title" style="margin-top:15px;">Conditions</div>
                    <div id="conditionList">
                        <div class="condition-item">
                            <div class="condition-row">
                                <select class="condition-param">
                                    <option>Speed</option>
                                    <option>IsGrounded</option>
                                    <option>IsJumping</option>
                                </select>
                                <select class="condition-param" style="width:60px;">
                                    <option>></option>
                                    <option><</option>
                                    <option>==</option>
                                    <option>!=</option>
                                </select>
                                <input type="number" class="condition-param" style="width:60px;" value="0.1">
                                <button class="condition-remove">X</button>
                            </div>
                        </div>
                    </div>
                    <button class="toolbar-btn" style="width:100%;margin-top:8px;">+ Add Condition</button>
                </div>

                <!-- Blend Space Properties -->
                <div class="panel-section" id="blendSpaceProps" style="display:none;">
                    <div class="section-title">Blend Space 2D</div>
                    <div class="property-row">
                        <span class="property-label">X Param</span>
                        <select class="property-input">
                            <option>VelocityX</option>
                            <option>VelocityZ</option>
                            <option>Speed</option>
                        </select>
                    </div>
                    <div class="property-row">
                        <span class="property-label">Y Param</span>
                        <select class="property-input">
                            <option>VelocityZ</option>
                            <option>VelocityX</option>
                            <option>Direction</option>
                        </select>
                    </div>
                    <div class="blend-space-2d" id="blendSpace2D">
                        <!-- Blend points added by JavaScript -->
                    </div>
                    <div class="property-row" style="margin-top:10px;">
                        <span class="property-label">X Value</span>
                        <input type="number" class="property-input" id="blendX" value="0" step="0.1">
                    </div>
                    <div class="property-row">
                        <span class="property-label">Y Value</span>
                        <input type="number" class="property-input" id="blendY" value="0" step="0.1">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class BlendStateEditor {
            constructor() {
                this.canvas = document.getElementById('graphCanvas');
                this.ctx = this.canvas.getContext('2d');

                this.states = [];
                this.transitions = [];
                this.parameters = [];

                this.selectedState = null;
                this.selectedTransition = null;
                this.hoveredState = null;

                this.isDragging = false;
                this.isPanning = false;
                this.isCreatingTransition = false;
                this.transitionStartState = null;

                this.viewOffset = { x: 0, y: 0 };
                this.viewZoom = 1;

                this.init();
            }

            init() {
                this.initSampleData();
                this.resize();
                window.addEventListener('resize', () => this.resize());

                this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
                this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
                this.canvas.addEventListener('wheel', (e) => this.onWheel(e));
                this.canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                // Toolbar
                document.getElementById('addStateBtn').addEventListener('click', () => this.addState());
                document.getElementById('autoLayoutBtn').addEventListener('click', () => this.autoLayout());
                document.getElementById('frameAllBtn').addEventListener('click', () => this.frameAll());
                document.getElementById('blendType').addEventListener('change', (e) => this.onBlendTypeChange(e.target.value));

                this.renderUI();
                this.render();
            }

            initSampleData() {
                this.states = [
                    { id: 'entry', name: 'Entry', x: 100, y: 200, type: 'entry', animation: null },
                    { id: 'idle', name: 'Idle', x: 300, y: 200, type: 'state', animation: 'idle.anim', speed: 1.0 },
                    { id: 'walk', name: 'Walk', x: 500, y: 100, type: 'state', animation: 'walk.anim', speed: 1.0 },
                    { id: 'run', name: 'Run', x: 500, y: 300, type: 'state', animation: 'run.anim', speed: 1.0 },
                    { id: 'any', name: 'Any State', x: 100, y: 400, type: 'any', animation: null }
                ];

                this.transitions = [
                    { from: 'entry', to: 'idle', duration: 0, conditions: [] },
                    { from: 'idle', to: 'walk', duration: 0.2, conditions: [{ param: 'Speed', op: '>', value: 0.1 }] },
                    { from: 'walk', to: 'idle', duration: 0.2, conditions: [{ param: 'Speed', op: '<', value: 0.1 }] },
                    { from: 'walk', to: 'run', duration: 0.15, conditions: [{ param: 'Speed', op: '>', value: 3.0 }] },
                    { from: 'run', to: 'walk', duration: 0.15, conditions: [{ param: 'Speed', op: '<', value: 3.0 }] },
                    { from: 'any', to: 'idle', duration: 0.1, conditions: [{ param: 'Reset', op: '==', value: true }] }
                ];

                this.parameters = [
                    { name: 'Speed', type: 'float', value: 0 },
                    { name: 'Direction', type: 'float', value: 0 },
                    { name: 'IsGrounded', type: 'bool', value: true },
                    { name: 'IsJumping', type: 'bool', value: false },
                    { name: 'Attack', type: 'trigger', value: false },
                    { name: 'Reset', type: 'trigger', value: false }
                ];
            }

            resize() {
                const container = this.canvas.parentElement;
                this.canvas.width = container.clientWidth;
                this.canvas.height = container.clientHeight;
                this.render();
            }

            renderUI() {
                // State list
                const stateList = document.getElementById('stateList');
                stateList.innerHTML = '';
                this.states.forEach(state => {
                    const item = document.createElement('div');
                    item.className = 'state-item' + (this.selectedState === state ? ' selected' : '');
                    item.innerHTML = `
                        <div class="state-indicator ${state.type}"></div>
                        <span>${state.name}</span>
                    `;
                    item.addEventListener('click', () => {
                        this.selectedState = state;
                        this.selectedTransition = null;
                        this.renderUI();
                        this.updateProperties();
                        this.render();
                    });
                    stateList.appendChild(item);
                });

                // Parameter list
                const paramList = document.getElementById('parameterList');
                paramList.innerHTML = '';
                this.parameters.forEach(param => {
                    const item = document.createElement('div');
                    item.className = 'parameter-item';
                    item.innerHTML = `
                        <span class="parameter-type ${param.type}">${param.type.toUpperCase()}</span>
                        <span>${param.name}</span>
                        <span class="parameter-value">${param.value}</span>
                    `;
                    paramList.appendChild(item);
                });
            }

            updateProperties() {
                const stateProps = document.getElementById('stateProps');
                const transitionProps = document.getElementById('transitionProps');

                if (this.selectedState && this.selectedState.type === 'state') {
                    stateProps.style.display = 'block';
                    transitionProps.style.display = 'none';

                    document.getElementById('stateName').value = this.selectedState.name;
                    document.getElementById('stateSpeed').value = this.selectedState.speed || 1.0;
                } else if (this.selectedTransition) {
                    stateProps.style.display = 'none';
                    transitionProps.style.display = 'block';

                    document.getElementById('transitionDuration').value = this.selectedTransition.duration;
                }
            }

            render() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                // Clear
                ctx.fillStyle = '#1a1a2a';
                ctx.fillRect(0, 0, w, h);

                // Grid
                this.renderGrid();

                // Apply view transform
                ctx.save();
                ctx.translate(this.viewOffset.x, this.viewOffset.y);
                ctx.scale(this.viewZoom, this.viewZoom);

                // Transitions
                this.transitions.forEach(t => this.renderTransition(t));

                // Creating transition line
                if (this.isCreatingTransition && this.transitionStartState) {
                    const start = this.transitionStartState;
                    ctx.strokeStyle = '#ffaa44';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(start.x + 60, start.y + 25);
                    ctx.lineTo(this.mouseX, this.mouseY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }

                // States
                this.states.forEach(s => this.renderState(s));

                ctx.restore();
            }

            renderGrid() {
                const ctx = this.ctx;
                const w = this.canvas.width;
                const h = this.canvas.height;

                ctx.strokeStyle = '#252535';
                ctx.lineWidth = 1;

                const gridSize = 50 * this.viewZoom;
                const offsetX = this.viewOffset.x % gridSize;
                const offsetY = this.viewOffset.y % gridSize;

                for (let x = offsetX; x < w; x += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    ctx.stroke();
                }

                for (let y = offsetY; y < h; y += gridSize) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    ctx.stroke();
                }
            }

            renderState(state) {
                const ctx = this.ctx;
                const isSelected = this.selectedState === state;
                const isHovered = this.hoveredState === state;

                const width = 120;
                const height = 50;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.fillRect(state.x + 3, state.y + 3, width, height);

                // Background
                let bgColor;
                switch (state.type) {
                    case 'entry': bgColor = '#2a6644'; break;
                    case 'any': bgColor = '#664422'; break;
                    default: bgColor = '#2a3a66';
                }
                ctx.fillStyle = bgColor;
                ctx.fillRect(state.x, state.y, width, height);

                // Border
                ctx.strokeStyle = isSelected ? '#ffaa44' : (isHovered ? '#4488ff' : '#404060');
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.strokeRect(state.x, state.y, width, height);

                // Title bar
                let titleColor;
                switch (state.type) {
                    case 'entry': titleColor = '#44ff88'; break;
                    case 'any': titleColor = '#ff8844'; break;
                    default: titleColor = '#4488ff';
                }
                ctx.fillStyle = titleColor;
                ctx.fillRect(state.x, state.y, width, 20);

                // Name
                ctx.fillStyle = state.type === 'state' ? '#ffffff' : '#1e1e2e';
                ctx.font = 'bold 11px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(state.name, state.x + width / 2, state.y + 14);

                // Animation name
                if (state.animation) {
                    ctx.fillStyle = '#a0a0b0';
                    ctx.font = '10px sans-serif';
                    ctx.fillText(state.animation, state.x + width / 2, state.y + 38);
                }
            }

            renderTransition(transition) {
                const ctx = this.ctx;
                const fromState = this.states.find(s => s.id === transition.from);
                const toState = this.states.find(s => s.id === transition.to);

                if (!fromState || !toState) return;

                const isSelected = this.selectedTransition === transition;

                const startX = fromState.x + 120;
                const startY = fromState.y + 25;
                const endX = toState.x;
                const endY = toState.y + 25;

                // Calculate curve control points
                const dx = endX - startX;
                const dy = endY - startY;
                const cx1 = startX + dx * 0.5;
                const cy1 = startY;
                const cx2 = startX + dx * 0.5;
                const cy2 = endY;

                // Draw curve
                ctx.strokeStyle = isSelected ? '#ffaa44' : '#a0a0b0';
                ctx.lineWidth = isSelected ? 3 : 2;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(cx1, cy1, cx2, cy2, endX, endY);
                ctx.stroke();

                // Arrow
                const angle = Math.atan2(endY - cy2, endX - cx2);
                const arrowSize = 10;

                ctx.fillStyle = ctx.strokeStyle;
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle - Math.PI / 6),
                    endY - arrowSize * Math.sin(angle - Math.PI / 6)
                );
                ctx.lineTo(
                    endX - arrowSize * Math.cos(angle + Math.PI / 6),
                    endY - arrowSize * Math.sin(angle + Math.PI / 6)
                );
                ctx.fill();

                // Duration label
                const midX = (startX + endX) / 2;
                const midY = (startY + endY) / 2 - 10;
                ctx.fillStyle = '#808080';
                ctx.font = '10px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(transition.duration + 's', midX, midY);
            }

            screenToWorld(x, y) {
                return {
                    x: (x - this.viewOffset.x) / this.viewZoom,
                    y: (y - this.viewOffset.y) / this.viewZoom
                };
            }

            hitTestState(x, y) {
                const world = this.screenToWorld(x, y);
                for (const state of this.states) {
                    if (world.x >= state.x && world.x <= state.x + 120 &&
                        world.y >= state.y && world.y <= state.y + 50) {
                        return state;
                    }
                }
                return null;
            }

            onMouseDown(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (e.button === 2) {
                    this.isPanning = true;
                    this.panStart = { x, y };
                    return;
                }

                if (e.shiftKey) {
                    const state = this.hitTestState(x, y);
                    if (state) {
                        this.isCreatingTransition = true;
                        this.transitionStartState = state;
                    }
                    return;
                }

                const state = this.hitTestState(x, y);
                if (state) {
                    this.selectedState = state;
                    this.selectedTransition = null;
                    this.isDragging = true;
                    const world = this.screenToWorld(x, y);
                    this.dragOffset = { x: world.x - state.x, y: world.y - state.y };
                } else {
                    this.selectedState = null;
                }

                this.renderUI();
                this.updateProperties();
                this.render();
            }

            onMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const world = this.screenToWorld(x, y);

                this.mouseX = world.x;
                this.mouseY = world.y;

                if (this.isPanning) {
                    this.viewOffset.x += x - this.panStart.x;
                    this.viewOffset.y += y - this.panStart.y;
                    this.panStart = { x, y };
                    this.render();
                    return;
                }

                if (this.isDragging && this.selectedState) {
                    this.selectedState.x = world.x - this.dragOffset.x;
                    this.selectedState.y = world.y - this.dragOffset.y;
                    this.render();
                    return;
                }

                if (this.isCreatingTransition) {
                    this.render();
                    return;
                }

                // Hover detection
                const hoveredState = this.hitTestState(x, y);
                if (hoveredState !== this.hoveredState) {
                    this.hoveredState = hoveredState;
                    this.render();
                }
            }

            onMouseUp(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                if (this.isCreatingTransition) {
                    const targetState = this.hitTestState(x, y);
                    if (targetState && targetState !== this.transitionStartState) {
                        this.transitions.push({
                            from: this.transitionStartState.id,
                            to: targetState.id,
                            duration: 0.2,
                            conditions: []
                        });
                    }
                }

                this.isDragging = false;
                this.isPanning = false;
                this.isCreatingTransition = false;
                this.transitionStartState = null;
                this.render();
            }

            onWheel(e) {
                e.preventDefault();
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const oldZoom = this.viewZoom;
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                this.viewZoom = Math.max(0.25, Math.min(2, this.viewZoom * zoomFactor));

                // Zoom towards mouse
                this.viewOffset.x = x - (x - this.viewOffset.x) * (this.viewZoom / oldZoom);
                this.viewOffset.y = y - (y - this.viewOffset.y) * (this.viewZoom / oldZoom);

                this.render();
            }

            addState() {
                const id = 'state_' + Date.now();
                const state = {
                    id,
                    name: 'New State',
                    x: 300 - this.viewOffset.x / this.viewZoom,
                    y: 200 - this.viewOffset.y / this.viewZoom,
                    type: 'state',
                    animation: 'idle.anim',
                    speed: 1.0
                };
                this.states.push(state);
                this.selectedState = state;
                this.renderUI();
                this.render();
            }

            autoLayout() {
                // Simple force-directed layout
                const iterations = 50;
                const repulsion = 5000;
                const attraction = 0.01;

                for (let iter = 0; iter < iterations; iter++) {
                    // Repulsion between all states
                    for (let i = 0; i < this.states.length; i++) {
                        for (let j = i + 1; j < this.states.length; j++) {
                            const a = this.states[i];
                            const b = this.states[j];
                            const dx = b.x - a.x;
                            const dy = b.y - a.y;
                            const dist = Math.sqrt(dx * dx + dy * dy) || 1;
                            const force = repulsion / (dist * dist);

                            a.x -= dx / dist * force;
                            a.y -= dy / dist * force;
                            b.x += dx / dist * force;
                            b.y += dy / dist * force;
                        }
                    }

                    // Attraction along transitions
                    this.transitions.forEach(t => {
                        const a = this.states.find(s => s.id === t.from);
                        const b = this.states.find(s => s.id === t.to);
                        if (!a || !b) return;

                        const dx = b.x - a.x;
                        const dy = b.y - a.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);

                        a.x += dx * attraction;
                        a.y += dy * attraction;
                        b.x -= dx * attraction;
                        b.y -= dy * attraction;
                    });
                }

                this.render();
            }

            frameAll() {
                if (this.states.length === 0) return;

                let minX = Infinity, minY = Infinity;
                let maxX = -Infinity, maxY = -Infinity;

                this.states.forEach(s => {
                    minX = Math.min(minX, s.x);
                    minY = Math.min(minY, s.y);
                    maxX = Math.max(maxX, s.x + 120);
                    maxY = Math.max(maxY, s.y + 50);
                });

                const centerX = (minX + maxX) / 2;
                const centerY = (minY + maxY) / 2;

                this.viewOffset.x = this.canvas.width / 2 - centerX * this.viewZoom;
                this.viewOffset.y = this.canvas.height / 2 - centerY * this.viewZoom;

                this.render();
            }

            onBlendTypeChange(type) {
                const stateProps = document.getElementById('stateProps');
                const blendSpaceProps = document.getElementById('blendSpaceProps');

                if (type === 'Blend Tree 2D') {
                    stateProps.style.display = 'none';
                    blendSpaceProps.style.display = 'block';
                } else {
                    stateProps.style.display = 'block';
                    blendSpaceProps.style.display = 'none';
                }
            }
        }

        // Initialize
        const editor = new BlendStateEditor();

        // Native bridge
        window.BlendStateEditor = {
            loadStateMachine: (data) => {
                editor.states = data.states || [];
                editor.transitions = data.transitions || [];
                editor.parameters = data.parameters || [];
                editor.renderUI();
                editor.render();
            },
            getStateMachineData: () => ({
                states: editor.states,
                transitions: editor.transitions,
                parameters: editor.parameters
            }),
            setParameter: (name, value) => {
                const param = editor.parameters.find(p => p.name === name);
                if (param) {
                    param.value = value;
                    editor.renderUI();
                }
            }
        };
    </script>
</body>
</html>
