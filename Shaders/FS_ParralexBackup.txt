#version 410

in vec2	vTexCoord;
in vec4 pixelLoc;
in vec3 surfaceNormal;
in vec3 surfaceTangent;

out vec4 FragColor;

uniform sampler2D diffuse;
uniform sampler2D normal;
uniform sampler2D heightmap;
uniform sampler2D roughness;
uniform sampler2D diffuse2;
uniform sampler2D normal2;

uniform vec3 camloc;
uniform float depth_step_shift;

uniform float waterHeight;
uniform float LerpPow;


vec3 Dir2Pixel;
vec3 inwardNormal;
float inwardDot;

vec2 UV_step_shift;
vec2 UV_refracted_step_shift;
vec2 Current_UV;
vec2 Last_UV;

float CurrentDepth;
float Lerp;

bool RayTouchesWater;

vec4 CalculateSteps(vec2 StartUV,float CapDepth,float RefractiveIndex,float StartDepth) //UV //MetCap // FindDepth;
{
	//Results
	vec2 ResultingUV;
	float MetCap = 0;
	float FoundAtDepth;


	vec3 Vvec = cross(surfaceTangent,surfaceNormal);
	float Udot = dot(surfaceTangent,Dir2Pixel);
	float Vdot = dot(Vvec,Dir2Pixel);
	float InvDot = 1/inwardDot;

	bool FoundCollision = false;
	float Step = 0;
	vec2 UV_step = vec2(InvDot*Udot*depth_step_shift,InvDot*Vdot*depth_step_shift)/RefractiveIndex;
	while(!FoundCollision)
	{
		vec2 CurrentUV = StartUV + UV_step*Step;
		float Current_Depth = depth_step_shift*Step + StartDepth;

		float DepthRespectiveToCap = CapDepth - (1-CurrentDepth*10);
		float DepthRespectiveToBase = texture(heightmap,CurrentUV).x - (1-CurrentDepth*10);

		if(DepthRespectiveToBase>0 && DepthRespectiveToCap>0)
		{
			if(DepthRespectiveToCap>DepthRespectiveToBase)
			{
				MetCap = 1; //Deeper into Cap Then Base
			}
			else
			{
					
			}
		}
		else if(DepthRespectiveToBase>0)
		{
			
		}
		else if(DepthRespectiveToCap>0)
		{
			MetCap = 1;
		}
		FoundCollision = true;
	}

	return vec4(0,0,0,0);
};

void main()
{
	inwardNormal = -surfaceNormal;
	Dir2Pixel = normalize(pixelLoc.xyz - camloc);
	inwardDot = dot(inwardNormal,Dir2Pixel);

	vec3 Vvec;

	float Udot;
	float Vdot;

	if(inwardDot>0)
	{

		Vvec = cross(surfaceTangent,surfaceNormal);
	
		Udot = dot(surfaceTangent,Dir2Pixel);
		Vdot = dot(Vvec,Dir2Pixel);
	
	

		bool AboveHeightmap = true;
		float Step = 0;
		float MaxSteps = 100;
	
		float LastDeltaDepth = 0;
		float ThisDeltaDepth;
		float InvDot = 1/inwardDot;
		UV_step_shift = vec2(InvDot*Udot*depth_step_shift,InvDot*Vdot*depth_step_shift);
		vec3 AdjustmentVector = InvDot*Dir2Pixel*depth_step_shift;

		while(AboveHeightmap && Step < MaxSteps)
		{
			Current_UV = UV_step_shift*Step+vTexCoord;
			CurrentDepth = depth_step_shift*Step;
			ThisDeltaDepth = texture(heightmap,Current_UV).x - (1-CurrentDepth*10);
			if(ThisDeltaDepth>0)
			{
				Lerp = LastDeltaDepth/(LastDeltaDepth-ThisDeltaDepth);
				
				AboveHeightmap = false;
			}

			//if(waterHeight>1-CurrentDepth*10)
			//{
			//	AboveHeightmap = false;
			//}


			Step = Step+1;
			LastDeltaDepth = ThisDeltaDepth;
		}
		Lerp = pow(Lerp,LerpPow);
		Last_UV = UV_step_shift*(Step-2)+vTexCoord;
		FragColor = texture(diffuse,(Lerp)*Current_UV+(1-Lerp)*Last_UV);


	}
	else
	{
		discard;
	}
};

		//if(waterHeight>1-CurrentDepth*10)
		//	FragColor = texture(diffuse2,Current_UV);
		//else
		//	FragColor = texture(diffuse,Current_UV);
