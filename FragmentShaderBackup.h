
	//Fragment Shader
	//==========================================================================================================================================
	//==========================================================================================================================================
	AddLine2Str(&FS_Source, "		#version 410																								 ");
	AddLine2Str(&FS_Source, "		in vec2	vTexCoord;																							 ");
	AddLine2Str(&FS_Source, "		out vec4 FragColor;																							 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		uniform vec3 CamLoc; //position of observation																 ");
	AddLine2Str(&FS_Source, "		uniform vec3 CamPointAt; //position of focus																 ");
	AddLine2Str(&FS_Source, "		uniform float FOV; //field of view angle																	 ");
	AddLine2Str(&FS_Source, "		uniform float Tilt; //angle the camera is tilted on.														 ");
	AddLine2Str(&FS_Source, "		uniform float AspectRatio;																					 ");
	AddLine2Str(&FS_Source, "		uniform float SphericalLensingRatio;																		 ");
	AddLine2Str(&FS_Source, "		uniform int MaxSteps;																						 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		vec3 GetSceneVector(vec3 foward, vec3 up, vec3 right)														 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			float XAngle = vTexCoord.x*FOV;																			 ");
	AddLine2Str(&FS_Source, "			float YAngle = vTexCoord.y*FOV / AspectRatio;															 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			vec3 TiltedRight = cos(XAngle)*foward + sin(XAngle)*right;												 ");
	AddLine2Str(&FS_Source, "			vec3 TiltedFinal = cos(YAngle)*TiltedRight + sin(YAngle)*up;											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			vec3 TiltedRight1 = (1 / tan(FOV))*foward + vTexCoord.x*right;											 ");
	AddLine2Str(&FS_Source, "			vec3 TiltedFinal1 = (TiltedRight1 + vTexCoord.y / AspectRatio*up);										 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			return normalize(TiltedFinal*SphericalLensingRatio + (1 - SphericalLensingRatio)*TiltedFinal1);			 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float v3Max(vec3 vector)																					 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			return max(max(vector.x, vector.y), vector.z);															 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float fMakeSphere(vec3 Point, float Radius)																	 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			return length(Point) - Radius;																			 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float fMakeColumn(vec2 Point, float Radius)																	 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			return length(Point) - Radius;																			 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float fMakeBox(vec3 Point, vec3 Bounds)																		 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			vec3 Basic = abs(Point) - Bounds;																		 ");
	AddLine2Str(&FS_Source, "			return length(max(Basic, vec3(0))) + v3Max(min(Basic, vec3(0)));										 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		int fTileSpace(inout float Dimension, float TileSize)														 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			int Result = int(floor((Dimension + TileSize / 2) / TileSize));											 ");
	AddLine2Str(&FS_Source, "			Dimension = mod(Dimension + TileSize / 2, TileSize) - TileSize / 2;										 ");
	AddLine2Str(&FS_Source, "			return Result;																							 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float Subract(float A, float B)																				 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			return max(A, -B);																						 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float Add(float A, float B)																					 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			return min(A, B);																						 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float InCommon(float A, float B)																			 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			return max(A, B);																						 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		void Shift(inout float Dimension, float Movement)															 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			Dimension = Dimension - Movement;																		 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		void Shift3(inout vec3 Space, vec3 Movement)																 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			Space = Space - Movement;																				 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		void Rotate(inout vec2 Plane, float Angle)																	 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			Plane = cos(Angle)*Plane + sin(Angle)*vec2(Plane.y, -Plane.x);											 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		void Mirror(inout float Dimension, float Distance)															 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			Dimension = abs(Dimension) - Distance;																	 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		float fFunction(vec3 Loc)																					 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	//FieldLocation
	fFieldLoc = FS_Source.length();
	
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		vec3 circleTrace(vec3 Start, vec3 Dir, float InterceptDistance)												 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			vec3 Location = Start;																					 ");
	AddLine2Str(&FS_Source, "			int Step = 0;																							 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			while (Step<MaxSteps)																					 ");
	AddLine2Str(&FS_Source, "			{																										 ");
	AddLine2Str(&FS_Source, "				float LengthToASurface = fFunction(Location);														 ");
	AddLine2Str(&FS_Source, "				if (LengthToASurface<InterceptDistance)																 ");
	AddLine2Str(&FS_Source, "				{																									 ");
	AddLine2Str(&FS_Source, "					return vec3(1, length(Location - Start), 0);													 ");
	AddLine2Str(&FS_Source, "				}																									 ");
	AddLine2Str(&FS_Source, "				else if (Location.y<0)																				 ");
	AddLine2Str(&FS_Source, "				{																									 ");
	AddLine2Str(&FS_Source, "					Location -= (Dir / Dir.y)*Location.y;															 ");
	AddLine2Str(&FS_Source, "					LengthToASurface = fFunction(Location);															 ");
	AddLine2Str(&FS_Source, "					return vec3(2, length(Location - Start), LengthToASurface);										 ");
	AddLine2Str(&FS_Source, "				}																									 ");
	AddLine2Str(&FS_Source, "				else																								 ");
	AddLine2Str(&FS_Source, "				{																									 ");
	AddLine2Str(&FS_Source, "					Step += 1;																						 ");
	AddLine2Str(&FS_Source, "					Location += Dir*LengthToASurface;																 ");
	AddLine2Str(&FS_Source, "				};																									 ");
	AddLine2Str(&FS_Source, "			};																										 ");
	AddLine2Str(&FS_Source, "			return vec3(0, length(Location - Start), 0);															 ");
	AddLine2Str(&FS_Source, "		}																											 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		void main()																									 ");
	AddLine2Str(&FS_Source, "		{																											 ");
	AddLine2Str(&FS_Source, "			//CameraSetup																							 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			vec3 Foward = normalize(CamPointAt - CamLoc);															 ");
	AddLine2Str(&FS_Source, "			vec3 Right = normalize(cross(Foward, vec3(0, 1, 0)));													 ");
	AddLine2Str(&FS_Source, "			vec3 Up = cross(Right, Foward);																			 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			vec3 TiltedRight = (cos(Tilt)*Right + sin(Tilt)*Up);													 ");
	AddLine2Str(&FS_Source, "			vec3 TiltedUp = cross(TiltedRight, Foward);																 ");
	AddLine2Str(&FS_Source, "			vec3 FinalVector = GetSceneVector(Foward, TiltedUp, TiltedRight);										 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			//TraceIntoField																						 ");
	AddLine2Str(&FS_Source, "			vec3 TraceResult = circleTrace(CamLoc, FinalVector, 0.01f);												 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "			//RespondToResult;																						 ");
	AddLine2Str(&FS_Source, "			if (TraceResult.x == 1)																					 ");
	AddLine2Str(&FS_Source, "			{																										 ");
	AddLine2Str(&FS_Source, "				FragColor = vec4(0.5f, 0.5f, 0.5f, 1);																 ");
	AddLine2Str(&FS_Source, "			}																										 ");
	AddLine2Str(&FS_Source, "			else if (TraceResult.x == 2)																			 ");
	AddLine2Str(&FS_Source, "			{																										 ");
	AddLine2Str(&FS_Source, "				//FragColor = vec4(0,0,0,1);																		 ");
	AddLine2Str(&FS_Source, "				if (int(TraceResult.z * 7) % 7 == 0)																 ");
	AddLine2Str(&FS_Source, "				{																									 ");
	AddLine2Str(&FS_Source, "					FragColor = vec4(0, 0, 0, 1);																	 ");
	AddLine2Str(&FS_Source, "				}																									 ");
	AddLine2Str(&FS_Source, "				else																								 ");
	AddLine2Str(&FS_Source, "				{																									 ");
	AddLine2Str(&FS_Source, "					FragColor = vec4(1.0f, TraceResult.z / 5, 1.0f, 1);												 ");
	AddLine2Str(&FS_Source, "				}																									 ");
	AddLine2Str(&FS_Source, "			}																										 ");
	AddLine2Str(&FS_Source, "			else																									 ");
	AddLine2Str(&FS_Source, "			{																										 ");
	AddLine2Str(&FS_Source, "				FragColor = vec4(0, 0, 0, 1);																		 ");
	AddLine2Str(&FS_Source, "			}																										 ");
	AddLine2Str(&FS_Source, "																													 ");
	AddLine2Str(&FS_Source, "		};			


	//FSigned Distance Function
	//==========================================================================================================================================
	//==========================================================================================================================================
	AddLine2Str(&F_FieldCode, "			int Cell = fTileSpace(Loc.x, 10);																		 ");
	AddLine2Str(&F_FieldCode, "			float Box = fMakeBox(Loc, vec3(2, 3, 4));																 ");
	AddLine2Str(&F_FieldCode, "			float Column = fMakeColumn(Loc.xz, 2);																	 ");
	AddLine2Str(&F_FieldCode, "			return Add(Box, Column);																				 ");
//==========================================================================================================================================
//==========================================================================================================================================
